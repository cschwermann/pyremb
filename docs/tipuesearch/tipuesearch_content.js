var tipuesearch = {"pages":[{"title":" PYREMB ","text":"PYREMB PYREMB The periodic embedding code PEREMB provides an interface between - in principle - arbitrary DFT codes to facilitate subsystem DFT calculations with isolated, periodic and mixed isolated-periodic systems. The program uses provided densities and atomic positions to calculate the non-additive kinetic potential, the non-additive exchange-correlation potential, the Hartree potential and the nuclear potential. Those potentials together yield the embedding potential, which can be printed out and used in DFT calculations with external programs. The source code is available at https://github.com/cschwermann/pyremb Note The program is incomplete and not in a usable state. Features The subroutines calculating the individual contributions to the embedding potential are clearly structured to be easily accessible in external programs by including specific modules. In particular, the subroutines could be called individually if not all contributions are needed (such as the electrostatic terms). An interpolation of all data belonging to a \"subsystem\" type onto the arbitrary grid of another \"subsystem\" type was implemented to allow the combination of arbitrary subsystems on arbitrary grids. This first implementation uses a basic Shepard algorithm. Integration subroutines for arbitrary grids were implemented, aiming at energy evaluations by integrating input potentials. In order to allow the usage of GGA functionals, the density functional subroutines were generalized to in principle call the respective libXC subroutines for GGA functionals, if a density gradient is provided. Calls to the libXC energy subroutines were also implemented. Non-Features While the individual subroutines were tested and found to be working, the current implementation of PEREMB is incomplete. In particular, \n * no python interface exists, as f2py is incompatible with the used Fortran types. Tests with F90Wrap were inconclusive.\n * The Shepard interpolation routine works well for small arrays, but scales quadratically with the number of grid points, which makes application to actual molecular systems unfeasible. \n * The energy evaluation is incomplete. The most difficult part is the calculation of inter-subsystem nuclei-nuclei interaction, as this might require an immensely fine grid or some kind of Ewald summation. Attempts to implement an Ewald summation method failed due to convergence difficulties.\n *Also, the libXC interface is not entirely clear as to what exactly is the output of the energy subroutines. The output is an array containing a value for each grid point; however, integration as well as integration of the product of the array with the density did not yield any meaningful value -- not even scaled by factors such as multiples of pi or the cell volume. Outlook Thus, further work is needed to develop a fully functional PEREMB version which enables FDE calculations with BAND:\n * Python wrappers might be created using \"forpy\". Otherwise, they have to be written manually (which should be possible).\n * More efficient implementations  of the Shepard interpolation exist  (e.g. within the NAG library), which reduce the quadratic scaling by only considering close-lying grid points. Otherwise, more sophisticated interpolation routines might be needed.\n * easily yield all the elctrostatic terms. \n * libXC could be entirely avoided by using XCfun; however, the documentation also does not seem very clear. Developer Info Christian Schwermann PhD student in the Doltsinis group at WWU Muenster","tags":"home","loc":"index.html"},{"title":"Do_test.F90 – PYREMB","text":"Contents Programs Do_test Source Code Do_test.F90 Source Code program Do_test implicit none integer , parameter :: DP = Selected_real_kind ( 15 , 307 ) real ( kind = DP ), allocatable :: array (:), array2 (:), temp (:) real ( kind = DP ) :: mysum , tstart , tend , mysum2 , value integer :: i , n , izero n = 100000000 allocate ( array ( 1 : n ) ) allocate ( array2 ( 1 : n ) ) allocate ( temp ( 1 : n ) ) array ( 1 : n ) = 1.0E-5_DP array2 ( 1 : n ) = 1.0E-5_DP !! normal do loop mysum = 0.0_DP call Cpu_time ( tstart ) do i = 1 , n mysum = mysum + array ( i ) end do call Cpu_time ( tend ) write ( * , * ) \"Normal:\" write ( * , * ) \"Sum: \" , mysum , \";  Timing: \" , tend - tstart , \" seconds\" !! concurrent do loop mysum = 0.0_DP call Cpu_time ( tstart ) do concurrent ( i = 1 : n ) mysum = mysum + array ( i ) end do call Cpu_time ( tend ) write ( * , * ) \"Concurrent:\" write ( * , * ) \"Sum: \" , mysum , \";  Timing: \" , tend - tstart , \" seconds\" !! intrinsic sum mysum = 0.0_DP call Cpu_time ( tstart ) mysum = Sum ( array ( 1 : n ) ) call Cpu_time ( tend ) write ( * , * ) \"Intrinsic:\" write ( * , * ) \"Sum: \" , mysum , \";  Timing: \" , tend - tstart , \" seconds\" !! 1 do loop mysum = 0.0_DP mysum2 = 0.0_DP call Cpu_time ( tstart ) do i = 1 , n mysum = mysum + array ( i ) mysum2 = mysum2 + array ( i ) end do call Cpu_time ( tend ) write ( * , * ) \"One Loop:\" write ( * , * ) \"Sum: \" , mysum , mysum2 , \";  Timing: \" , tend - tstart , \" seconds\" !! 2 do loops mysum = 0.0_DP mysum2 = 0.0_DP call Cpu_time ( tstart ) do i = 1 , n mysum = mysum + array ( i ) end do do i = 1 , n mysum2 = mysum2 + array ( i ) end do call Cpu_time ( tend ) write ( * , * ) \"Two Loops:\" write ( * , * ) \"Sum: \" , mysum , mysum2 , \";  Timing: \" , tend - tstart , \" seconds\" !! 2 do loops mysum = 0.0_DP mysum2 = 0.0_DP call Cpu_time ( tstart ) mysum = Sum ( array ( 1 : n ) ) mysum2 = Sum ( array ( 1 : n ) ) call Cpu_time ( tend ) write ( * , * ) \"2* Intrinsic\" write ( * , * ) \"Sum: \" , mysum , mysum2 , \";  Timing: \" , tend - tstart , \" seconds\" !! Other test: array maths and sum !! 1 do loop mysum = 0.0_DP call Cpu_time ( tstart ) do i = 1 , n mysum = mysum + array ( i ) - array2 ( i ) end do call Cpu_time ( tend ) write ( * , * ) \"One Loop:\" write ( * , * ) \"Sum: \" , mysum , \";  Timing: \" , tend - tstart , \" seconds\" !! intrinsic mysum = 0.0_DP call Cpu_time ( tstart ) mysum = Sum ( array ( 1 : n ) - array2 ( 1 : n ) ) call Cpu_time ( tend ) write ( * , * ) \"Intrinsic Loop:\" write ( * , * ) \"Sum: \" , mysum , \";  Timing: \" , tend - tstart , \" seconds\" !! temp array mysum = 0.0_DP call Cpu_time ( tstart ) temp ( 1 : n ) = array ( 1 : n ) - array2 ( 1 : n ) do i = 1 , n mysum = mysum + temp ( i ) end do call Cpu_time ( tend ) write ( * , * ) \"Temp array:\" write ( * , * ) \"Sum: \" , mysum , \";  Timing: \" , tend - tstart , \" seconds\" !! Other test: specifically what i do in shepard interpolation array ( 1 : n ) = 2.0E-5_DP array ( n / 2 ) = 1.0E-5_DP !! temp array mysum = 0.0_DP call Cpu_time ( tstart ) do concurrent ( i = 1 : n ) value = Abs ( array ( i ) - array2 ( i ) ) temp ( i ) = value if ( value <= 1.0E-10_DP ) izero = i end do do concurrent ( i = 1 : izero ) mysum = mysum + temp ( i ) end do call Cpu_time ( tend ) write ( * , * ) \"Temp array:\" write ( * , * ) \"Sum: \" , mysum , izero , \";  Timing: \" , tend - tstart , \" seconds\" !! one loop mysum = 0.0_DP call Cpu_time ( tstart ) do concurrent ( i = 1 : n ) value = Abs ( array ( i ) - array2 ( i ) ) if ( value <= 1.0E-10_DP ) izero = i mysum = mysum + value end do call Cpu_time ( tend ) write ( * , * ) \"One loop:\" write ( * , * ) \"Sum: \" , mysum , izero , \";  Timing: \" , tend - tstart , \" seconds\" !! one loop with exit mysum = 0.0_DP call Cpu_time ( tstart ) do i = 1 , n value = Abs ( array ( i ) - array2 ( i ) ) if ( value <= 1.0E-10_DP ) then izero = i exit end if mysum = mysum + value end do call Cpu_time ( tend ) write ( * , * ) \"One loop with exit:\" write ( * , * ) \"Sum: \" , mysum , izero , \";  Timing: \" , tend - tstart , \" seconds\" end program Do_test","tags":"","loc":"sourcefile/do_test.f90.html"},{"title":"Output_mod.F90 – PYREMB","text":"This file depends on sourcefile~~output_mod.f90~~EfferentGraph sourcefile~output_mod.f90 Output_mod.F90 sourcefile~precision_mod.f90 Precision_mod.F90 sourcefile~output_mod.f90->sourcefile~precision_mod.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~output_mod.f90~~AfferentGraph sourcefile~output_mod.f90 Output_mod.F90 sourcefile~xcpot_mod.f90 Xcpot_mod.F90 sourcefile~xcpot_mod.f90->sourcefile~output_mod.f90 sourcefile~types_mod.f90 Types_mod.F90 sourcefile~xcpot_mod.f90->sourcefile~types_mod.f90 sourcefile~utils_mod.f90 Utils_mod.F90 sourcefile~xcpot_mod.f90->sourcefile~utils_mod.f90 sourcefile~system_mod.f90 System_mod.F90 sourcefile~system_mod.f90->sourcefile~output_mod.f90 sourcefile~system_mod.f90->sourcefile~types_mod.f90 sourcefile~peremb_mod.f90 Peremb_mod.F90 sourcefile~peremb_mod.f90->sourcefile~output_mod.f90 sourcefile~peremb_mod.f90->sourcefile~system_mod.f90 sourcefile~peremb_mod.f90->sourcefile~utils_mod.f90 sourcefile~xcpot_libxc_mod.f90 Xcpot_libxc_mod.F90 sourcefile~xcpot_libxc_mod.f90->sourcefile~output_mod.f90 sourcefile~types_mod.f90->sourcefile~output_mod.f90 sourcefile~utils_mod.f90->sourcefile~output_mod.f90 sourcefile~utils_mod.f90->sourcefile~types_mod.f90 sourcefile~test.f90 Test.F90 sourcefile~test.f90->sourcefile~xcpot_mod.f90 sourcefile~test.f90->sourcefile~system_mod.f90 sourcefile~test.f90->sourcefile~types_mod.f90 sourcefile~test.f90->sourcefile~utils_mod.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules Output_mod Source Code Output_mod.F90 Source Code !! Author:  Christian Schwermann !! E-mail:  c.schwermann@wwu.de !! Date:    15/03/2019 !! Project: PEREMB !! File:    Output_mod.F90 !! Copyright: © 2019 Christian Schwermann, ALL RIGHTS RESERVED !! !!*********************************************************************** !! !! Definition of Error and Warning functions used throughout all of PEREMB !! !!*********************************************************************** module Output_mod use Precision_mod ! IEEE precision implicit none ! Error and Warning functions public :: Error , Warning contains !!******************************************************************** !! Throw an Error determined by a string, print some numbers and !! exit with non-zero status !!******************************************************************** subroutine Error ( string , int1 , int2 , real1 , real2 ) !! Input: string describing the error character ( len =* ), intent ( in ) :: string !! Input: integers to print out, optional integer , optional , intent ( in ) :: int1 , int2 !! Input: floats to print out, optional real ( kind = DP ), optional , intent ( in ) :: real1 , real2 !! write ( * , * ) \"ERROR! \" , string if ( Present ( int1 ) ) write ( * , * ) \"(1)=\" , int1 if ( Present ( int2 ) ) write ( * , * ) \"(2)=\" , int2 if ( Present ( real1 ) ) write ( * , * ) \"(1)=\" , real1 if ( Present ( real2 ) ) write ( * , * ) \"(2)=\" , real2 error stop end subroutine Error !!******************************************************************** !! Throw a Warnig determined by a string, print some numbers, but !! do not exit !!******************************************************************** subroutine Warning ( string , int1 , int2 , real1 , real2 ) !! Input: string describing the error character ( len =* ), intent ( in ) :: string !! Input: integers to print out, optional integer , optional , intent ( in ) :: int1 , int2 !! Input: floats to print out, optional real ( kind = DP ), optional , intent ( in ) :: real1 , real2 !! write ( * , * ) \"WARNING! \" , string if ( Present ( int1 ) ) write ( * , * ) \"(1)=\" , int1 if ( Present ( int2 ) ) write ( * , * ) \"(2)=\" , int2 if ( Present ( real1 ) ) write ( * , * ) \"(1)=\" , real1 if ( Present ( real2 ) ) write ( * , * ) \"(2)=\" , real2 end subroutine Warning end module Output_mod","tags":"","loc":"sourcefile/output_mod.f90.html"},{"title":"Peremb_mod.F90 – PYREMB","text":"This file depends on sourcefile~~peremb_mod.f90~~EfferentGraph sourcefile~peremb_mod.f90 Peremb_mod.F90 sourcefile~utils_mod.f90 Utils_mod.F90 sourcefile~peremb_mod.f90->sourcefile~utils_mod.f90 sourcefile~output_mod.f90 Output_mod.F90 sourcefile~peremb_mod.f90->sourcefile~output_mod.f90 sourcefile~system_mod.f90 System_mod.F90 sourcefile~peremb_mod.f90->sourcefile~system_mod.f90 sourcefile~precision_mod.f90 Precision_mod.F90 sourcefile~peremb_mod.f90->sourcefile~precision_mod.f90 sourcefile~utils_mod.f90->sourcefile~output_mod.f90 sourcefile~utils_mod.f90->sourcefile~precision_mod.f90 sourcefile~types_mod.f90 Types_mod.F90 sourcefile~utils_mod.f90->sourcefile~types_mod.f90 sourcefile~output_mod.f90->sourcefile~precision_mod.f90 sourcefile~system_mod.f90->sourcefile~output_mod.f90 sourcefile~system_mod.f90->sourcefile~types_mod.f90 sourcefile~types_mod.f90->sourcefile~output_mod.f90 sourcefile~types_mod.f90->sourcefile~precision_mod.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules Peremb_mod Source Code Peremb_mod.F90 Source Code !! Author:  Christian Schwermann !! E-mail:  c.schwermann@wwu.de !! Date:    14/03/2019 !! Project: PEREMB !! File:    Peremb_mod.F90 !! Copyright: © 2019 Christian Schwermann, ALL RIGHTS RESERVED !! !!*********************************************************************** !! !! Main subroutines for periodic subystem DFT calculations !! !!*********************************************************************** module Peremb_mod use Precision_mod ! IEEE precision use Output_mod ! Error and warning use utils_mod ! Some maths use System_mod ! System and subsystems implicit none ! Embedding potential for predefined system public :: Embedding_potential ! Embedding energy for predefined system public :: Embedding_energy contains !!******************************************************************** !! Calculation of embedding potential for the global system. !! !! Only needs eXchange, Correlation and Kinetic functionals as input !! and returns the effective embedding potential !!******************************************************************** subroutine Embedding_potential ( x_func , c_func , k_func , potential ) !! Input: exchange functional character ( * ), intent ( in ) :: x_func !! Input: correlation functional character ( * ), intent ( in ) :: c_func !! Input: kinetic functional character ( * ), intent ( in ) :: k_func !! Output: embedding potential real ( kind = DP ), intent ( out ) :: potential (:) !! Internal: temporary molecule, total system type ( molecule_t ) :: molecule , total !! Internal: temporary grid type ( grid_t ) :: grid !! Internal: #points for active system, index of active subsystem, loop index integer :: ngpt , iactive , i !! Internal: temporary potential real ( kind = DP ), allocatable :: temppot (:) !! do i = 1 , nsys if ( system ( i )% active ) then ngpt = system ( i )% ngpt grid = system ( i )% grid total = system ( i ) iactive = i end if end do potential ( 1 : ngpt ) = 0.0_DP allocate ( temppot ( 1 : ngpt ) ) do i = 1 , nsys molecule = system ( i ) if ( . not . molecule % active ) then call Mol_interpolate ( molecule , grid ) if ( Mol_has_vnuc ( molecule ) ) then potential (:) = potential (:) + molecule % vnuc (:) else !TODO calculate vnuc from ions call Error ( \"Embedding_potential: Need vnuc!\" ) end if end if call Mol_set_density ( total , total % density (:) + molecule % density (:) ) end do ! Total system DFT energy call Xc_potential ( total , x_func , temppot ) potential (:) = potential (:) + temppot (:) call Xc_potential ( total , c_func , temppot ) potential (:) = potential (:) + temppot (:) call Xc_potential ( total , k_func , temppot ) potential (:) = potential (:) + temppot (:) ! active system DFT energy call Xc_potential ( system ( iactive ), x_func , temppot ) potential (:) = potential (:) - temppot (:) call Xc_potential ( system ( iactive ), c_func , temppot ) potential (:) = potential (:) - temppot (:) call Xc_potential ( system ( iactive ), k_func , temppot ) potential (:) = potential (:) - temppot (:) deallocate ( temppot ) end subroutine Embedding_potential !!******************************************************************** !! Calculation of embedding energy for the global system. !! !! Only needs eXchange, Correlation and Kinetic functionals as input !! and returns the effective embedding energy on the active grid !! @TODO calculate energy on a common supergrid @ENDTODO !!******************************************************************** subroutine Embedding_energy ( x_func , c_func , k_func , energy ) !! Input: exchange functional character ( * ), intent ( in ) :: x_func !! Input: correlation functional character ( * ), intent ( in ) :: c_func !! Input: kinetic functional character ( * ), intent ( in ) :: k_func !! Output: embedding potential real ( kind = DP ), intent ( out ) :: energy !! Internal: temporary molecule type ( molecule_t ) :: molecule , total !! Internal: temporary grid type ( grid_t ) :: grid !! Internal: #points for active system, index of active system, loop index integer :: ngpt , iactive , i !! Internal: temporary energy real ( kind = DP ) :: tempener !! do i = 1 , nsys if ( system ( i )% active ) then ngpt = system ( i )% ngpt grid = system ( i )% grid total = system ( i ) iactive = i end if end do energy = 0.0_DP do i = 1 , nsys molecule = system ( i ) if ( . not . molecule % active ) then call Mol_interpolate ( molecule , grid ) if ( Mol_has_vnuc ( molecule ) ) then call Mol_set_vnuc ( total , total % vnuc (:) + molecule % vnuc (:) ) else !TODO calculate vnuc from ions call Error ( \"Embedding_potential: Need vnuc!\" ) end if end if call Mol_set_density ( total , total % density (:) + molecule % density (:) ) end do ! Electrostatic energy energy = energy + Integrate ( system ( iactive )% vnuc (:) * total % density (:), grid ) energy = energy + Integrate ( molecule % vnuc (:) * system ( iactive )% density (:), grid ) ! Total system DFT energy call Xc_energy ( total , x_func , tempener ) energy = energy + tempener call Xc_energy ( total , c_func , tempener ) energy = energy + tempener call Xc_energy ( total , k_func , tempener ) energy = energy + tempener ! active system DFT energy call Xc_energy ( system ( iactive ), x_func , tempener ) energy = energy - tempener call Xc_energy ( system ( iactive ), c_func , tempener ) energy = energy - tempener call Xc_energy ( system ( iactive ), k_func , tempener ) energy = energy - tempener end subroutine Embedding_energy end module Peremb_mod","tags":"","loc":"sourcefile/peremb_mod.f90.html"},{"title":"Precision_mod.F90 – PYREMB","text":"Files dependent on this one sourcefile~~precision_mod.f90~~AfferentGraph sourcefile~precision_mod.f90 Precision_mod.F90 sourcefile~xcpot_mod.f90 Xcpot_mod.F90 sourcefile~xcpot_mod.f90->sourcefile~precision_mod.f90 sourcefile~output_mod.f90 Output_mod.F90 sourcefile~xcpot_mod.f90->sourcefile~output_mod.f90 sourcefile~types_mod.f90 Types_mod.F90 sourcefile~xcpot_mod.f90->sourcefile~types_mod.f90 sourcefile~utils_mod.f90 Utils_mod.F90 sourcefile~xcpot_mod.f90->sourcefile~utils_mod.f90 sourcefile~output_mod.f90->sourcefile~precision_mod.f90 sourcefile~peremb_mod.f90 Peremb_mod.F90 sourcefile~peremb_mod.f90->sourcefile~precision_mod.f90 sourcefile~peremb_mod.f90->sourcefile~output_mod.f90 sourcefile~peremb_mod.f90->sourcefile~utils_mod.f90 sourcefile~system_mod.f90 System_mod.F90 sourcefile~peremb_mod.f90->sourcefile~system_mod.f90 sourcefile~test.f90 Test.F90 sourcefile~test.f90->sourcefile~precision_mod.f90 sourcefile~test.f90->sourcefile~xcpot_mod.f90 sourcefile~test.f90->sourcefile~types_mod.f90 sourcefile~test.f90->sourcefile~utils_mod.f90 sourcefile~test.f90->sourcefile~system_mod.f90 sourcefile~xcpot_libxc_mod.f90 Xcpot_libxc_mod.F90 sourcefile~xcpot_libxc_mod.f90->sourcefile~precision_mod.f90 sourcefile~xcpot_libxc_mod.f90->sourcefile~output_mod.f90 sourcefile~types_mod.f90->sourcefile~precision_mod.f90 sourcefile~types_mod.f90->sourcefile~output_mod.f90 sourcefile~utils_mod.f90->sourcefile~precision_mod.f90 sourcefile~utils_mod.f90->sourcefile~output_mod.f90 sourcefile~utils_mod.f90->sourcefile~types_mod.f90 sourcefile~system_mod.f90->sourcefile~output_mod.f90 sourcefile~system_mod.f90->sourcefile~types_mod.f90 var pansourcefileprecision_modf90AfferentGraph = svgPanZoom('#sourcefileprecision_modf90AfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules Precision_mod Source Code Precision_mod.F90 Source Code !! Author:  Christian Schwermann !! E-mail:  c.schwermann@wwu.de !! Date:    15/03/2019 !! Project: PEREMB !! File:    Precision_mod.F90 !! Copyright: © 2019 Christian Schwermann, ALL RIGHTS RESERVED !! !!*********************************************************************** !! !! Consistent definition of precisions, should be IEE-754 standard !! !!*********************************************************************** module Precision_mod implicit none ! Single  double and quadruple precision public :: SP , DP , QP !! Single precision integer , parameter :: SP = Selected_real_kind ( p = 6 , r = 37 ) !! Double precision integer , parameter :: DP = Selected_real_kind ( p = 15 , r = 307 ) !! Quadruple precision integer , parameter :: QP = Selected_real_kind ( p = 33 , r = 4931 ) end module Precision_mod","tags":"","loc":"sourcefile/precision_mod.f90.html"},{"title":"System_mod.F90 – PYREMB","text":"This file depends on sourcefile~~system_mod.f90~~EfferentGraph sourcefile~system_mod.f90 System_mod.F90 sourcefile~output_mod.f90 Output_mod.F90 sourcefile~system_mod.f90->sourcefile~output_mod.f90 sourcefile~types_mod.f90 Types_mod.F90 sourcefile~system_mod.f90->sourcefile~types_mod.f90 sourcefile~precision_mod.f90 Precision_mod.F90 sourcefile~output_mod.f90->sourcefile~precision_mod.f90 sourcefile~types_mod.f90->sourcefile~output_mod.f90 sourcefile~types_mod.f90->sourcefile~precision_mod.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~system_mod.f90~~AfferentGraph sourcefile~system_mod.f90 System_mod.F90 sourcefile~peremb_mod.f90 Peremb_mod.F90 sourcefile~peremb_mod.f90->sourcefile~system_mod.f90 sourcefile~test.f90 Test.F90 sourcefile~test.f90->sourcefile~system_mod.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules System_mod Source Code System_mod.F90 Source Code !! Author:  Christian Schwermann !! E-mail:  c.schwermann@wwu.de !! Date:    15/03/2019 !! Project: PEREMB !! File:    System_mod.F90 !! Copyright: © 2019 Christian Schwermann, ALL RIGHTS RESERVED !! !!*********************************************************************** !! !! Definition of the GLOBAL total system, which can contain any number of molecules. !! !!*********************************************************************** module System_mod use Output_mod ! Error and warning use Types_mod ! molecule type implicit none ! Number of molecules in the system, system (array of molecules) public :: nsys , system ! System initialization public :: Sys_init ! values hould be saved, so that subroutines can modify the system globally save !TODO Maybe add a nice subroutine to extend a system !(by creating a larger system and copying everything) !! Number of subsystems, the only thing you have to know beforehand integer :: nsys !! THE system, just an array of molecules, but GLOBAL! type ( molecule_t ), allocatable :: system (:) contains !! Basic initialization of the system, not specifying any molecules subroutine Init ( numsys ) !! Input: number of subsystems integer , intent ( in ) :: numsys !! nsys = numsys allocate ( system ( nsys ) ) end subroutine Init !! Initialize a subsystem, optionally with all important parameters. subroutine Sys_init ( subsystem , density , vnuc , gridweights , gridpositions , active , spin ) !! Input: index of the subsystem integer , intent ( in ) :: subsystem !! Input: density, 1D array of length ngpt (or 2*ngpt if spin polarized; order is a, b) real ( kind = DP ), intent ( in ) :: density (:) !! Input: nuclear potential, of length ngpt real ( kind = DP ), optional , intent ( in ) :: vnuc (:) !! Input: grid weights, length ngpt real ( kind = DP ), optional , intent ( in ) :: gridweights (:) !! Input: grid positions, length (3,ngpt) real ( kind = DP ), optional , intent ( in ) :: gridpositions (:,:) !! Input: whether the system is active logical , optional , intent ( in ) :: active !! Input: whether the system is spin polarized logical , optional , intent ( in ) :: spin !! Internal :: number of grid points integer :: ngpt !! if ( . not . Allocated ( system ) ) & & call Error ( \"Sys_init: system not initialized!\" ) ngpt = Size ( density ) if ( Present ( spin ) ) then if ( spin ) then ngpt = ngpt / 2 end if end if system ( subsystem ) = molecule_t ( ngpt = ngpt ) ! set spin first, as density depends on it if ( Present ( spin ) ) & & system ( subsystem )% spinpol = spin call Mol_set_density ( system ( subsystem ), density ) if ( Present ( vnuc ) ) & & call Mol_set_vnuc ( system ( subsystem ), vnuc ) if ( Present ( gridweights ) ) then if ( Present ( gridpositions ) ) then call Mol_init_grid ( system ( subsystem ), weights = gridweights , positions = gridpositions ) else call Mol_init_grid ( system ( subsystem ), weights = gridweights ) end if end if if ( Present ( active ) ) & & system ( subsystem )% active = active end subroutine Sys_init end module System_mod","tags":"","loc":"sourcefile/system_mod.f90.html"},{"title":"Test.F90 – PYREMB","text":"This file depends on sourcefile~~test.f90~~EfferentGraph sourcefile~test.f90 Test.F90 sourcefile~xcpot_mod.f90 Xcpot_mod.F90 sourcefile~test.f90->sourcefile~xcpot_mod.f90 sourcefile~system_mod.f90 System_mod.F90 sourcefile~test.f90->sourcefile~system_mod.f90 sourcefile~types_mod.f90 Types_mod.F90 sourcefile~test.f90->sourcefile~types_mod.f90 sourcefile~precision_mod.f90 Precision_mod.F90 sourcefile~test.f90->sourcefile~precision_mod.f90 sourcefile~utils_mod.f90 Utils_mod.F90 sourcefile~test.f90->sourcefile~utils_mod.f90 sourcefile~xcpot_mod.f90->sourcefile~types_mod.f90 sourcefile~xcpot_mod.f90->sourcefile~precision_mod.f90 sourcefile~xcpot_mod.f90->sourcefile~utils_mod.f90 sourcefile~output_mod.f90 Output_mod.F90 sourcefile~xcpot_mod.f90->sourcefile~output_mod.f90 sourcefile~system_mod.f90->sourcefile~types_mod.f90 sourcefile~system_mod.f90->sourcefile~output_mod.f90 sourcefile~types_mod.f90->sourcefile~precision_mod.f90 sourcefile~types_mod.f90->sourcefile~output_mod.f90 sourcefile~utils_mod.f90->sourcefile~types_mod.f90 sourcefile~utils_mod.f90->sourcefile~precision_mod.f90 sourcefile~utils_mod.f90->sourcefile~output_mod.f90 sourcefile~output_mod.f90->sourcefile~precision_mod.f90 var pansourcefiletestf90EfferentGraph = svgPanZoom('#sourcefiletestf90EfferentGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Programs Test Source Code Test.F90 Source Code !! Author:  Christian Schwermann !! E-mail:  c.schwermann@wwu.de !! Date:    15/03/2019 !! Project: PEREMB !! File:    Test.F90 !! Copyright: © 2019 Christian Schwermann, ALL RIGHTS RESERVED !! !!*********************************************************************** !! !! Test of most of the functions and subroutines, just to see if they work / are correct !! !!*********************************************************************** program Test use Precision_mod ! IEEE Precision use Types_mod ! Molecule, grid and ions type use System_mod ! global system use Utils_mod ! Utilities use XCpot_mod ! DFT implicit none !! number of grid points, number of atoms, loop index integer :: ngpt , natoms , i !! density, nuclear potential, ion charges, ion positions, cell, another density real ( kind = DP ) :: dens ( 1 : 3 ), vnuc ( 1 : 3 ), q ( 1 : 4 ), pos ( 1 : 3 , 1 : 4 ), cell ( 1 : 3 , 1 : 3 ), dens2 ( 1 : 2 ) !! three molecules type ( molecule_t ) :: mol1 , mol2 , mol3 !! grid type ( grid_t ) :: grid1 !! dft energy and effective potential real ( kind = DP ) :: ener , pot ( 1 : 3 ) !! grid positions for two grids, reference and result function for interpolation test real ( kind = DP ) :: positions1 ( 1 : 3 , 1 : 4 ), positions2 ( 1 : 3 , 1 : 5 ), func ( 1 : 4 ), res_func ( 1 : 5 ) !! write ( * , * ) \"Test Program\" ! initialization ngpt = 3 dens = ( / 1.0_DP , 2.0_DP , 3.0_DP / ) vnuc = ( / 4.0_DP , 5.0_DP , 6.0_DP / ) natoms = 4 q = ( / 1.0_DP , 2.0_DP , 3.0_DP , 4.0_DP / ) pos = 0.0_DP do i = 1 , 4 pos ( 1 , i ) = i * 0.1_DP pos ( 2 , i ) = i * 0.2_DP pos ( 3 , i ) = i * 0.3_DP end do cell = 0.0_DP do i = 1 , 3 cell ( i , i ) = 5.0_DP end do ! Test molecule type mol1 = molecule_t ( ngpt = ngpt , density = dens ) mol2 = mol1 ! Test molecule initialization call Mol_set_vnuc ( mol1 , vnuc ) call Mol_init_ions ( mol1 , natoms , q , pos ) call Mol_init_grid ( mol1 , cell = cell ) ! Output: \"Has\"-functions write ( * , * ) Mol_has_vnuc ( mol1 ), Mol_has_ions ( mol1 ), Mol_has_grid ( mol1 ) write ( * , * ) mol1 % vnuc write ( * , * ) Ions_has_charges ( mol1 % ions ) write ( * , * ) mol1 % grid % cell write ( * , * ) Mol_has_vnuc ( mol2 ), Mol_has_ions ( mol2 ), Mol_has_grid ( mol2 ) ! Test molecule Settings: ions, grid call Mol_set_ions ( mol2 , mol1 % ions ) call Mol_set_grid ( mol2 , mol1 % grid ) write ( * , * ) Mol_has_vnuc ( mol2 ), Mol_has_ions ( mol2 ), Mol_has_grid ( mol2 ) ! Test molecule Settings: spin, density, gradient call Mol_set_spin ( mol2 , . true . ) call Mol_set_density ( mol2 , ( / dens , dens / ) ) call Mol_set_gradient ( mol2 , ( / dens , dens , dens / ) ) ! Different initialization, also works mol3 = molecule_t ( ngpt = ngpt , spinpol = . true ., density = ( / dens , dens / ), gradient = ( / dens , dens , dens / ) ) mol3 % vnuc = ( / 1.0_DP , 2.0_DP , 3.0_DP , 4.0_DP / ) ! Output: \"Has\"-functions write ( * , * ) Mol_has_density ( mol3 ), Mol_has_gradient ( mol3 ), Mol_has_grid ( mol3 ), Mol_has_vnuc ( mol3 ) ! Test system nitialization call Sys_init ( 3 ) system ( 1 ) = mol1 system ( 2 ) = mol2 system ( 3 ) = mol3 system ( 2 )% active = . true . write ( * , * ) \"System:\" , nsys , system ( 1 )% active , system ( 2 )% active , system ( 3 )% active ! Test integration write ( * , * ) \"Density integral:\" , Integrate ( dens ) grid1 = grid_T ( & & ngpt = 3 , & & weights = ( / 0.1_DP , 0.2_DP , 0.3_DP / ) ) write ( * , * ) \"Weighted density integral:\" , Integrate ( dens , grid1 ) ! Test DFT procedures for libxc call Xc_energy ( mol1 , \"LDA_XC_TETER93\" , ener ) write ( * , * ) \"LDA Energy:\" , ener call Xc_potential ( mol1 , \"LDA_XC_TETER93\" , pot ) write ( * , * ) \"LDA Potential:\" , pot call Xc_energy ( mol3 , \"GGA_XC_PBE1W\" , ener ) write ( * , * ) \"PBE Energy:\" , ener positions1 (:, :) = 0.0_DP positions1 ( 1 , :) = ( / 1.0_DP , 3.0_DP , 5.0_DP , 7.0_DP / ) positions2 (:, :) = 0.0_DP positions2 ( 1 , :) = ( / 0.0_DP , 2.0_DP , 4.0_DP , 6.0_DP , 8.0_DP / ) ! simple x**2 function as test func (:) = positions1 ( 1 , :) ** 2 ! Test Shepard interpolation call Shepard_interpolate ( positions1 , func , positions2 , res_func ) ! Print reference write ( * , * ) \"Interpolation: reference\" write ( * , * ) \"Integral:\" , Integrate ( func ) * 2.0_DP write ( * , '(A5,A5)' ) \"X\" , \"Y\" do i = 1 , 4 write ( * , '(F5.1,F5.1)' ) positions1 ( 1 , i ), func ( i ) end do ! Print result write ( * , * ) \"Interpolation: result\" write ( * , * ) \"Integral:\" , Integrate ( res_func ) * 2.0_DP write ( * , '(A5,A5)' ) \"X\" , \"Y\" do i = 1 , 5 write ( * , '(F5.1,F5.1)' ) positions2 ( 1 , i ), res_func ( i ) end do ! Also see what happens if we try to get our reference from the result call Shepard_interpolate ( positions2 , res_func , positions1 , func ) ! Print reference obtained from interpolating twice write ( * , * ) \"Interpolation: reference backwards\" write ( * , * ) \"Integral:\" , Integrate ( func ) * 2.0_DP write ( * , '(A5,A5)' ) \"X\" , \"Y\" do i = 1 , 4 write ( * , '(F5.1,F5.1)' ) positions1 ( 1 , i ), func ( i ) end do ! Test already known positions positions1 ( 1 , :) = ( / 5.0_DP , 3.0_DP , 5.0_DP , 7.0_DP / ) positions2 ( 1 , :) = ( / 2.0_DP , 3.0_DP , 5.0_DP , 6.0_DP , 8.0_DP / ) call Shepard_interpolate ( positions1 , func , positions2 , res_func ) ! Print results write ( * , * ) \"Interpolation: result\" write ( * , * ) \"Integral:\" , Integrate ( res_func ) * 2.0_DP write ( * , '(A5,A5)' ) \"X\" , \"Y\" do i = 1 , 5 write ( * , '(F5.1,F5.1)' ) positions2 ( 1 , i ), res_func ( i ) end do !TODO test Mol_interpolate ! Test error termination dens2 = ( / 1.0_DP , 2.0_DP / ) call Mol_set_density ( mol2 , dens2 ) end program Test","tags":"","loc":"sourcefile/test.f90.html"},{"title":"Types_mod.F90 – PYREMB","text":"This file depends on sourcefile~~types_mod.f90~~EfferentGraph sourcefile~types_mod.f90 Types_mod.F90 sourcefile~output_mod.f90 Output_mod.F90 sourcefile~types_mod.f90->sourcefile~output_mod.f90 sourcefile~precision_mod.f90 Precision_mod.F90 sourcefile~types_mod.f90->sourcefile~precision_mod.f90 sourcefile~output_mod.f90->sourcefile~precision_mod.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~types_mod.f90~~AfferentGraph sourcefile~types_mod.f90 Types_mod.F90 sourcefile~utils_mod.f90 Utils_mod.F90 sourcefile~utils_mod.f90->sourcefile~types_mod.f90 sourcefile~xcpot_mod.f90 Xcpot_mod.F90 sourcefile~xcpot_mod.f90->sourcefile~types_mod.f90 sourcefile~xcpot_mod.f90->sourcefile~utils_mod.f90 sourcefile~system_mod.f90 System_mod.F90 sourcefile~system_mod.f90->sourcefile~types_mod.f90 sourcefile~test.f90 Test.F90 sourcefile~test.f90->sourcefile~types_mod.f90 sourcefile~test.f90->sourcefile~utils_mod.f90 sourcefile~test.f90->sourcefile~xcpot_mod.f90 sourcefile~test.f90->sourcefile~system_mod.f90 sourcefile~peremb_mod.f90 Peremb_mod.F90 sourcefile~peremb_mod.f90->sourcefile~utils_mod.f90 sourcefile~peremb_mod.f90->sourcefile~system_mod.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules Types_mod Source Code Types_mod.F90 Source Code !! Author:  Christian Schwermann !! E-mail:  c.schwermann@wwu.de !! Date:    14/03/2019 !! Project: PEREMB !! File:    Types_mod.F90 !! Copyright: © 2019 Christian Schwermann, ALL RIGHTS RESERVED !! !!*********************************************************************** !! !! Definition of all Data Types and their functions !! !!*********************************************************************** module Types_mod use Precision_mod ! IEEE precision use Output_mod ! Error and warning implicit none ! Grid type, Ions type, Molecule type public :: grid_t , ions_t , molecule_t ! Molecule functions and subroutines public :: Mol_has_grid , Mol_has_vnuc , Mol_has_ions , Mol_has_density , Mol_has_gradient public :: Mol_set_grid , Mol_set_vnuc , Mol_set_ions , Mol_set_spin , Mol_set_density , & & Mol_set_density_a , Mol_set_density_b , Mol_set_gradient , Mol_set_gradient_aa , & & Mol_set_gradient_ab , Mol_set_gradient_bb , Mol_init_grid , Mol_init_ions ! Grid functions and subroutines public :: Grid_has_weights , Grid_has_cell , Grid_has_positions , Grid_has_points_xyz , & & Grid_has_periodicity public :: Grid_set_weights , Grid_set_cell , Grid_set_positions , Grid_set_points_xyz ! Ions functions and subroutines public :: Ions_has_charges , Ions_has_positions public :: Ions_set_charges , Ions_set_positions !!******************************************************************** !! Grid type, contains points, weights, cell and positions !!******************************************************************** type :: grid_t !! Number of grid points integer :: ngpt !! Number of grid points in each direction, for periodic cells integer :: ngptx = - 1.0_DP , ngpty = - 1.0_DP , ngptz = - 1.0_DP !! Weights; size = ngpt, optional real ( kind = DP ), allocatable :: weights (:) !! Cell vectors; size = (3, 3), optional real ( kind = DP ), allocatable :: cell (:, :) !! Positions; size = (3, ngpt), first index is x,y,z, optional real ( kind = DP ), allocatable :: positions (:, :) !! end type grid_t !!******************************************************************** !! Ions type, contains number, charges and positions !!******************************************************************** type :: ions_t !! Number of ions integer :: nions !! Charges; size = nions real ( kind = DP ), allocatable :: charges (:) !! Positions; size = (3, nions), first index is x,y,z real ( kind = DP ), allocatable :: positions (:, :) !! end type ions_t !!******************************************************************** !! Molecule type, contains points, grid, density, nuclear potential and ions !!******************************************************************** type :: molecule_t !! Number of grid points integer :: ngpt !! Grid, may contain weights, cell and positions type ( grid_t ), pointer :: grid => null () !! Electron density; size = ngpt for unpolarized or 2 * ngpt for spin polarized, beta is from ngpt + 1:2 * ngpt real ( kind = DP ), allocatable :: density (:) !! Density gradient |\\nabla\\rho|&#94;2; size = npgt for unpolarized or 3 * ngpt for spin polarized, order is aa,ab,bb real ( kind = DP ), allocatable :: gradient (:) !! Nuclear potential; size = ngpt, alternative to ions real ( kind = DP ), allocatable :: vnuc (:) !! Ions, contains number of ions, charges and positions type ( ions_t ), pointer :: ions => null () !! Spin polarized or not logical :: spinpol = . false . !! Active or not logical :: active = . false . !! end type molecule_t contains !******************************************************************** ! Molecule functions !******************************************************************** !! Return .true. if the molecule has a grid. pure function Mol_has_grid ( this ) result ( hasgrid ) !! Input: molecule type ( molecule_t ), intent ( in ) :: this !! Output: whether the molecule has a grid logical :: hasgrid !! hasgrid = Associated ( this % grid ) end function Mol_has_grid !! Return .true. if the molecule has a vnuc (nuclear potential). pure function Mol_has_vnuc ( this ) result ( hasvnuc ) !! Input: molecule type ( molecule_t ), intent ( in ) :: this !! Output: whether the molecule has a vnuc logical :: hasvnuc !! hasvnuc = Allocated ( this % vnuc ) end function Mol_has_vnuc !! Return .true. if the molecule has ions. pure function Mol_has_ions ( this ) result ( hasions ) !! Input: molecule type ( molecule_t ), intent ( in ) :: this !! Output: whether the molecule has ions logical :: hasions !! hasions = Associated ( this % ions ) end function Mol_has_ions !! Return .true. if the molecule has a density. pure function Mol_has_density ( this ) result ( hasdensity ) !! Input: molecule type ( molecule_t ), intent ( in ) :: this !! Output: whether the molecule has a density logical :: hasdensity !! hasdensity = Allocated ( this % density ) end function Mol_has_density !! Return .true. if the molecule has a density gradient. pure function Mol_has_gradient ( this ) result ( hasgradient ) !! Input: molecule type ( molecule_t ), intent ( in ) :: this !! Output: whether the molecule has a gradient logical :: hasgradient !! hasgradient = Allocated ( this % gradient ) end function Mol_has_gradient !! Set the grid of a molecule. Initialize a grid if none exists. subroutine Mol_set_grid ( this , grid ) !! Input: molecule type ( molecule_t ), intent ( inout ) :: this !! Input: grid, ngpt has to be ngpt of molecule type ( grid_t ), intent ( in ) :: grid !! if ( grid % ngpt /= this % ngpt ) & & call Error ( \"Mol_set_grid: grid%ngpt /= this%ngpt\" , grid % ngpt , this % ngpt ) if ( . not . Mol_has_grid ( this ) ) allocate ( this % grid ) this % grid = grid end subroutine Mol_set_grid !! Set the nuclear potential of a molecule. Initialize one if none exists. subroutine Mol_set_vnuc ( this , vnuc ) !! Input: molecule type ( molecule_t ), intent ( inout ) :: this !! Input: nuclear potential, 1D array of size ngpt real ( kind = DP ), intent ( in ) :: vnuc (:) !! Internal: start and end index of vnuc integer :: istart , iend !! if ( Size ( vnuc ) /= this % ngpt ) & & call Error ( \"Mol_set_vnuc: Size(vnuc) /= this%ngpt\" , Size ( vnuc ), this % ngpt ) istart = Lbound ( vnuc , 1 ) iend = Ubound ( vnuc , 1 ) if ( . not . Mol_has_vnuc ( this ) ) allocate ( this % vnuc ( 1 : this % ngpt ) ) this % vnuc ( 1 : this % ngpt ) = vnuc ( istart : iend ) end subroutine Mol_set_vnuc !! Set the ions of a molecule. Initialize if none exist. pure subroutine Mol_set_ions ( this , ions ) !! Input: molecule type ( molecule_t ), intent ( inout ) :: this !! Input: ions type ( ions_t ), intent ( in ) :: ions !! if ( . not . Mol_has_ions ( this ) ) allocate ( this % ions ) this % ions = ions end subroutine Mol_set_ions !! Set the spin of a molecule. If density or gradient exist, they are deallocated! subroutine Mol_set_spin ( this , spinpol ) !! Input: molecule type ( molecule_t ), intent ( inout ) :: this !! Input: spin ( .true. = spin polarized, .false. = unpolarized ) logical , intent ( in ) :: spinpol !! this % spinpol = spinpol if ( Mol_has_density ( this ) ) then call Warning ( \"Mol_set_spin: setting spin after density! Deallocating density!\" ) deallocate ( this % density ) endif if ( Mol_has_gradient ( this ) ) then call Warning ( \"Mol_set_spin: setting spin after gradient! Deallocating gradient!\" ) deallocate ( this % gradient ) endif end subroutine Mol_set_spin !! Set the density of a molecule. Initialize density if none exists. subroutine Mol_set_density ( this , density ) !! Input: molecule type ( molecule_t ), intent ( inout ) :: this !! Input: density, 1D array of length ngpt (or 2*ngpt if spin polarized; order is a, b) real ( kind = DP ), intent ( in ) :: density (:) !! Internal :: supposed size of density, start and end of input density integer :: dsize , istart , iend !! if ( this % spinpol ) then dsize = 2 * this % ngpt else dsize = this % ngpt end if if ( Size ( density ) /= dsize ) & & call Error ( \"Mol_set_density: Size(density) /= 2 * this%ngpt\" , Size ( density ), dsize ) istart = Lbound ( density , 1 ) iend = Ubound ( density , 1 ) if ( . not . Mol_has_density ( this ) ) allocate ( this % density ( 1 : dsize ) ) this % density ( 1 : dsize ) = density ( istart : iend ) end subroutine Mol_set_density !! Set the alpha spin density of a molecule. Initialize density if none exists. subroutine Mol_set_density_a ( this , density ) !! Input: molecule type ( molecule_t ), intent ( inout ) :: this !! Input: density, 1D array of length ngpt real ( kind = DP ), intent ( in ) :: density (:) !! Internal :: supposed size of density, start and end of input density integer :: dsize , istart , iend !! dsize = 2 * this % ngpt if ( . not . this % spinpol ) & & call Error ( \"Mol_set_density_a: trying to set alpha density for non spin polarized molecule!\" ) if ( Size ( density ) /= this % ngpt ) & & call Error ( \"Mol_set_density_a: Size(density) /= this%ngpt\" , Size ( density ), this % ngpt ) istart = Lbound ( density , 1 ) iend = Ubound ( density , 1 ) if ( . not . Mol_has_density ( this ) ) allocate ( this % density ( 1 : dsize ) ) this % density ( 1 : this % ngpt ) = density ( istart : iend ) end subroutine Mol_set_density_a !! Set the beta spin density of a molecule. Initialize density if none exists. subroutine Mol_set_density_b ( this , density ) !! Input: molecule type ( molecule_t ), intent ( inout ) :: this !! Input: density, 1D array of length ngpt real ( kind = DP ), intent ( in ) :: density (:) !! Internal :: supposed size of density, start and end of input density integer :: dsize , istart , iend !! dsize = 2 * this % ngpt if ( . not . this % spinpol ) & & call Error ( \"Mol_set_density_b: trying to set beta density for non spin polarized molecule!\" ) if ( Size ( density ) /= this % ngpt ) & & call Error ( \"Mol_set_density_b: Size(density) /= this%ngpt\" , Size ( density ), this % ngpt ) istart = Lbound ( density , 1 ) iend = Ubound ( density , 1 ) if ( . not . Mol_has_density ( this ) ) allocate ( this % density ( 1 : dsize ) ) this % density ( this % ngpt + 1 : dsize ) = density ( istart : iend ) end subroutine Mol_set_density_b !! Set the density gradient of a molecule. Initialize gradient if none exists. subroutine Mol_set_gradient ( this , gradient ) !! Input: molecule type ( molecule_t ), intent ( inout ) :: this !! Input: gradient, 1D array of length ngpt (3* ngpt if spin polarized; order is aa, ab, bb) real ( kind = DP ), intent ( in ) :: gradient (:) !! Internal :: supposed size of gradient, start and end of input gradient integer :: dsize , istart , iend !! if ( this % spinpol ) then dsize = 3 * this % ngpt else dsize = this % ngpt end if if ( Size ( gradient ) /= dsize ) & & call Error ( \"Mol_set_gradient: Size(gradient) /= 3 * this%ngpt\" , Size ( gradient ), dsize ) istart = Lbound ( gradient , 1 ) iend = Ubound ( gradient , 1 ) if ( . not . Mol_has_gradient ( this ) ) allocate ( this % gradient ( dsize ) ) this % gradient ( 1 : dsize ) = gradient ( istart : iend ) end subroutine Mol_set_gradient !! Set the aa density gradient of a molecule. Initialize gradient if none exists. subroutine Mol_set_gradient_aa ( this , gradient ) !! Input: molecule type ( molecule_t ), intent ( inout ) :: this !! Input: gradient, 1D array of length ngpt real ( kind = DP ), intent ( in ) :: gradient (:) !! Internal :: supposed size of gradient, start and end of input gradient integer :: dsize , istart , iend !! dsize = 3 * this % ngpt if ( . not . this % spinpol ) & & call Error ( \"Mol_set_gradient_aa: trying to set alpha gradient for non spin polarized molecule!\" ) if ( Size ( gradient ) /= dsize ) & & call Error ( \"Mol_set_gradient_aa: Size(gradient) /= this%ngpt\" , Size ( gradient ), this % ngpt ) istart = Lbound ( gradient , 1 ) iend = Ubound ( gradient , 1 ) if ( . not . Mol_has_gradient ( this ) ) allocate ( this % gradient ( dsize ) ) this % gradient ( 1 : this % ngpt ) = gradient ( istart : iend ) end subroutine Mol_set_gradient_aa !! Set the aa density gradient of a molecule. Initialize gradient if none exists. subroutine Mol_set_gradient_ab ( this , gradient ) !! Input: molecule type ( molecule_t ), intent ( inout ) :: this !! Input: gradient, 1D array of length ngpt real ( kind = DP ), intent ( in ) :: gradient (:) !! Internal :: supposed size of gradient, start and end of input gradient integer :: dsize , istart , iend !! dsize = 3 * this % ngpt if ( . not . this % spinpol ) & & call Error ( \"Mol_set_gradient_ab: trying to set alpha*beta gradient for non spin polarized molecule!\" ) if ( Size ( gradient ) /= this % ngpt ) & & call Error ( \"Mol_set_gradient_ab: Size(gradient) /= this%ngpt\" , Size ( gradient ), this % ngpt ) istart = Lbound ( gradient , 1 ) iend = Ubound ( gradient , 1 ) if ( . not . Mol_has_gradient ( this ) ) allocate ( this % gradient ( dsize ) ) this % gradient ( this % ngpt + 1 : 2 * this % ngpt ) = gradient ( istart : iend ) end subroutine Mol_set_gradient_ab !! Set the aa density gradient of a molecule. Initialize gradient if none exists. subroutine Mol_set_gradient_bb ( this , gradient ) !! Input: molecule type ( molecule_t ), intent ( inout ) :: this !! Input: gradient, 1D array of length ngpt real ( kind = DP ), intent ( in ) :: gradient (:) !! Internal :: supposed size of gradient, start and end of input gradient integer :: dsize , istart , iend !! dsize = 3 * this % ngpt if ( . not . this % spinpol ) & & call Error ( \"Mol_set_gradient_bb: trying to set beta gradient for non spin polarized molecule!\" ) if ( Size ( gradient ) /= this % ngpt ) & & call Error ( \"Mol_set_gradient_bb: Size(gradient) /= this%ngpt\" , Size ( gradient ), this % ngpt ) istart = Lbound ( gradient , 1 ) iend = Ubound ( gradient , 1 ) if ( . not . Mol_has_gradient ( this ) ) Allocate ( this % gradient ( dsize ) ) this % gradient ( 2 * this % ngpt + 1 : dsize ) = gradient ( istart : iend ) end subroutine Mol_set_gradient_bb !! Initialize the grid of a molecule. This requires nothing, but accepts weights, cell information and grid positions. subroutine Mol_init_grid ( this , weights , cell , positions ) !! Input: molecule type ( molecule_t ), intent ( inout ) :: this !! Input: grid weights, size ngpt real ( kind = DP ), optional , intent ( in ) :: weights (:) !! Input: unit cell, size (3, 3) real ( kind = DP ), optional , intent ( in ) :: cell (:, :) !! Input: grid weights, size (3, ngpt); first index is x, y, z real ( kind = DP ), optional , intent ( in ) :: positions (:, :) !! if ( Mol_has_grid ( this ) ) & & call Error ( \"Mol_init_grid: grid already initialized\" ) allocate ( this % grid ) this % grid = grid_t ( ngpt = this % ngpt ) if ( Present ( weights ) ) then call Grid_set_weights ( this % grid , weights ) end if if ( Present ( cell ) ) then call Grid_set_cell ( this % grid , cell ) end if if ( Present ( positions ) ) then call Grid_set_positions ( this % grid , positions ) end if end subroutine Mol_init_grid !! Initialize the ions of a molecule. This requires #ions, their charges and xyz positions. subroutine Mol_init_ions ( this , nions , charges , positions ) !! Input: molecule type ( molecule_t ), intent ( inout ) :: this !! Input: number of ions integer , intent ( in ) :: nions !! Input: nuclear (effective) charges, size nions real ( kind = DP ), intent ( in ) :: charges (:) !! Input: nuclear positions, size (3, nions); first index is x, y, z real ( kind = DP ), intent ( in ) :: positions (:, :) !! if ( Mol_has_ions ( this ) ) & & call Error ( \"Mol_init_ions: ions already initialized\" ) allocate ( this % ions ) this % ions = ions_t ( nions = nions ) call Ions_set_charges ( this % ions , charges ) call Ions_set_positions ( this % ions , positions ) end subroutine Mol_init_ions !******************************************************************** ! Grid functions !******************************************************************** !! Return .true. if the grid has weights. pure function Grid_has_weights ( this ) result ( hasweights ) !! Input: grid type ( grid_t ), intent ( in ) :: this !! Output: whether the grid has weights logical :: hasweights !! hasweights = Allocated ( this % weights ) end function Grid_has_weights !! Return .true. if the grid has a cell. pure function Grid_has_cell ( this ) result ( hascell ) !! Input: grid type ( grid_t ), intent ( in ) :: this !! Output: whether the grid has a cell logical :: hascell !! hascell = Allocated ( this % cell ) end function Grid_has_cell !! Return .true. if the grid has positions. pure function Grid_has_positions ( this ) result ( haspositions ) !! Input: grid type ( grid_t ), intent ( in ) :: this !! Output: whether the grid has a cell logical :: haspositions !! haspositions = Allocated ( this % positions ) end function Grid_has_positions !! Return .true. if the grid has points for all directions pure function Grid_has_points_xyz ( this ) result ( haspointsxyz ) !! Input: grid type ( grid_t ), intent ( in ) :: this !! Output: whether the grid has points for all directions logical :: haspointsxyz !! haspointsxyz = ( this % ngptx >= 0.0_DP & & . and . this % ngpty >= 0.0_DP & & . and . this % ngptz >= 0.0_DP ) end function Grid_has_points_xyz !! Return .true. if the grid has all properties associated with periodicity pure function Grid_has_periodicity ( this ) result ( hasperiodicity ) !! Input: grid type ( grid_t ), intent ( in ) :: this !! Output: whether the grid has all properties associated with periodicity logical :: hasperiodicity !! hasperiodicity = Grid_has_cell ( this ) . and . Grid_has_points_xyz ( this ) end function Grid_has_periodicity !! Set the weights of a grid. Initialize weights if none exist. subroutine Grid_set_weights ( this , weights ) !! Input: grid type ( grid_t ), intent ( inout ) :: this !! Input: weights, 1D array of size ngpt real ( kind = DP ), intent ( in ) :: weights (:) !! Internal :: start and end of input weights integer :: istart , iend !! if ( Size ( weights ) /= this % ngpt ) & & call Error ( \"Grid_set_weights: Size(weights) /= this%ngpt\" , Size ( weights ), this % ngpt ) istart = Lbound ( weights , 1 ) iend = Ubound ( weights , 1 ) if ( . not . Grid_has_weights ( this ) ) allocate ( this % weights ( 1 : this % ngpt ) ) this % weights ( 1 : this % ngpt ) = weights ( istart : iend ) end subroutine Grid_set_weights !! Set the x y and z points of a grid. subroutine Grid_set_points_xyz ( this , ngptx , ngpty , ngptz ) !! Input: grid type ( grid_t ), intent ( inout ) :: this !! Input: grid points in each direction integer , intent ( in ) :: ngptx , ngpty , ngptz !! if ( this % ngptx < 0.0_DP & & . or . this % ngpty < 0.0_DP & & . or . this % ngptz < 0.0_DP ) & & call Error ( \"Grid_set_points_xyz: Number of points must be non-negative!\" ) if ( ngptx * ngpty * ngptz /= this % ngpt ) & & call Error ( \"Grid_set_points_xyz: ngptx * ngpty * ngptz /= this%ngpt!\" , ngptx * ngpty * ngptz , this % ngpt ) this % ngptx = ngptx this % ngptx = ngpty this % ngptx = ngptz end subroutine Grid_set_points_xyz !! Set the cell of a grid. Initialize cell if none exists. subroutine Grid_set_cell ( this , cell , ngptx , ngpty , ngptz ) !! Input: grid type ( grid_t ), intent ( inout ) :: this !! Input: cell, 2D array of size (3, 3), contains cell vectors real ( kind = DP ), intent ( in ) :: cell (:, :) !! Input, optional: grid points in each direction integer , optional , intent ( in ) :: ngptx , ngpty , ngptz !! Internal :: start and end of input cell for each dimension integer :: istart1 , iend1 , istart2 , iend2 !! ! If grid points for cell are given, set them if ( Present ( ngptx ) ) then if ( Present ( ngpty ) . and . Present ( ngptz ) ) then call Grid_set_points_xyz ( this , ngptx , ngpty , ngptz ) else call Error ( \"Grid_set_cell: Need number of points in all three directions for periodic cells!\" ) end if end if if ( Size ( cell ) /= 9 ) & & call Error ( \"Grid_set_cell: shape(cell) incorrect\" , Size ( cell ), 9 ) istart1 = Lbound ( cell , 1 ) iend1 = Ubound ( cell , 1 ) istart2 = Lbound ( cell , 2 ) iend2 = Ubound ( cell , 2 ) if ( . not . Grid_has_cell ( this ) ) allocate ( this % cell ( 1 : 3 , 1 : 3 ) ) this % cell ( 1 : 3 , 1 : 3 ) = cell ( istart1 : iend1 , istart2 : iend2 ) end subroutine Grid_set_cell !! Set the positions of a grid. Initialize positions if none exist. subroutine Grid_set_positions ( this , positions ) !! Input: grid type ( grid_t ), intent ( inout ) :: this !! Input: cell, 2D array of size (3, ngpt), first index is x, y, z real ( kind = DP ), intent ( in ) :: positions (:, :) !! Internal :: start and end of input positions for each dimension integer :: istart1 , iend1 , istart2 , iend2 !! if ( Size ( positions ) /= 3 * this % ngpt ) & & call Error ( \"Grid_set_positions: shape(positions) incorrect\" , Size ( positions ), 3 * this % ngpt ) istart1 = Lbound ( positions , 1 ) iend1 = Ubound ( positions , 1 ) istart2 = Lbound ( positions , 2 ) iend2 = Ubound ( positions , 2 ) if ( . not . Grid_has_positions ( this ) ) allocate ( this % positions ( 1 : 3 , 1 : this % ngpt ) ) this % positions ( 1 : 3 , 1 : this % ngpt ) = positions ( istart1 : iend1 , istart2 : iend2 ) end subroutine Grid_set_positions !******************************************************************** ! Ions functions !******************************************************************** !! Return .true. if the ions have charges. !! Even though ions should always be initialized with charges, it is not impossible to not have charges. pure function Ions_has_charges ( this ) result ( hascharges ) !! Input: ions type ( ions_t ), intent ( in ) :: this !! Output: whether the ions have charges logical :: hascharges !! hascharges = Allocated ( this % charges ) end function Ions_has_charges !! Return .true. if the ions have positions. !! Even though ions should always be initialized with positions, it is not impossible to not have positions. pure function Ions_has_positions ( this ) result ( haspositions ) !! Input: ions type ( ions_t ), intent ( in ) :: this !! Output: whether the ions have positions logical :: haspositions !! haspositions = Allocated ( this % positions ) end function Ions_has_positions !! Set the charges of ions. Initialize charges if none exist. subroutine Ions_set_charges ( this , charges ) !! Input: ions type ( ions_t ), intent ( inout ) :: this !! Input: charges, 1D array of size nions real ( kind = DP ), intent ( in ) :: charges (:) !! Internal: start and end of input charges integer :: istart , iend !! if ( Size ( charges ) /= this % nions ) & & call Error ( \"Ions_set_charges: Size(charges) /= this%nions\" , Size ( charges ), this % nions ) istart = Lbound ( charges , 1 ) iend = Ubound ( charges , 1 ) if ( . not . Ions_has_charges ( this ) ) allocate ( this % charges ( 1 : this % nions ) ) this % charges ( 1 : this % nions ) = charges ( istart : iend ) end subroutine Ions_set_charges !! Set the positions of ions. Initialize positions if none exist. subroutine Ions_set_positions ( this , positions ) !! Input: ions type ( ions_t ), intent ( inout ) :: this !! Input: charges, 2D array of size (3, nions) real ( kind = DP ), intent ( in ) :: positions (:, :) !! Internal :: start and end of input positions for each dimension integer :: istart1 , iend1 , istart2 , iend2 !! if ( Size ( positions ) /= 3 * this % nions ) & & call Error ( \"Ions_set_positions: shape(positions incorrect\" , Size ( positions ), 3 * this % nions ) istart1 = Lbound ( positions , 1 ) iend1 = Ubound ( positions , 1 ) istart2 = Lbound ( positions , 2 ) iend2 = Ubound ( positions , 2 ) if ( . not . Ions_has_positions ( this ) ) allocate ( this % positions ( 1 : 3 , 1 : this % nions ) ) this % positions ( 1 : 3 , 1 : this % nions ) = positions ( istart1 : iend1 , istart2 : iend2 ) end subroutine Ions_set_positions end module Types_mod","tags":"","loc":"sourcefile/types_mod.f90.html"},{"title":"Utils_mod.F90 – PYREMB","text":"This file depends on sourcefile~~utils_mod.f90~~EfferentGraph sourcefile~utils_mod.f90 Utils_mod.F90 sourcefile~types_mod.f90 Types_mod.F90 sourcefile~utils_mod.f90->sourcefile~types_mod.f90 sourcefile~precision_mod.f90 Precision_mod.F90 sourcefile~utils_mod.f90->sourcefile~precision_mod.f90 sourcefile~output_mod.f90 Output_mod.F90 sourcefile~utils_mod.f90->sourcefile~output_mod.f90 sourcefile~types_mod.f90->sourcefile~precision_mod.f90 sourcefile~types_mod.f90->sourcefile~output_mod.f90 sourcefile~output_mod.f90->sourcefile~precision_mod.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~utils_mod.f90~~AfferentGraph sourcefile~utils_mod.f90 Utils_mod.F90 sourcefile~peremb_mod.f90 Peremb_mod.F90 sourcefile~peremb_mod.f90->sourcefile~utils_mod.f90 sourcefile~xcpot_mod.f90 Xcpot_mod.F90 sourcefile~xcpot_mod.f90->sourcefile~utils_mod.f90 sourcefile~test.f90 Test.F90 sourcefile~test.f90->sourcefile~utils_mod.f90 sourcefile~test.f90->sourcefile~xcpot_mod.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules Utils_mod Source Code Utils_mod.F90 Source Code !! Author:  Christian Schwermann !! E-mail:  c.schwermann@wwu.de !! Date:    15/03/2019 !! Project: PEREMB !! File:    Utils_mod.F90 !! Copyright: © 2019 Christian Schwermann, ALL RIGHTS RESERVED !! !!*********************************************************************** !! !! Utility module, contains generally useful subroutines and functions !! like integration, interpolation and other \"light\" math !! !!*********************************************************************** module Utils_mod use Precision_mod ! IEEE precision use Types_mod ! molecule and grid use Output_mod ! Error and warning implicit none ! Basic integration, Shepard interpolation and general interpolation for molecules public :: Integrate , Shepard_interpolate , Mol_interpolate ! Grid volume, cross product, grid positions public :: Grid_volume , Cross , Grid_pos_from_cell ! Arbitrary gradients public :: Gradient contains !!******************************************************************** !! Integration of arbitrary functions a_i  on arbitrary grids. !! !! This is simply a sum, i. e.  \\sum_{i=1}&#94;{N_{gpt}} w_i \\cdot a_i  !! when weights w_i are given and  \\sum_{i=1}&#94;{N_{gpt}} a_i  else. !! !! Here array is a_i, grid%weights is w_i, ngpot is N_{gpt}. !!******************************************************************** function Integrate ( array , grid ) result ( integral ) !! Input: any array real ( kind = DP ), intent ( in ) :: array (:) !! Input: grid, has to have the same number of points as the array type ( grid_t ), optional , intent ( in ) :: grid !! Output: the calculated integral real ( kind = DP ) :: integral !! Internal: loop index, start and end of array integer :: i , istart , iend !! Internal: volume of periodic cell real ( kind = DP ) :: volume !! !!@TODO Specific method for cells @ENDTODO integral = 0.0_DP istart = Lbound ( array , 1 ) iend = Ubound ( array , 1 ) ! Calculation depends on the grid having weights, a cell or nothing if ( Present ( grid ) ) then if ( Size ( array ) /= grid % ngpt ) & & call Error ( \"Integrate: Size( array ) /= grid%ngpt\" , Size ( array ), grid % ngpt ) if ( Grid_has_weights ( grid ) ) then if ( istart /= Lbound ( grid % weights , 1 ) ) & & call Error ( \"Integrate: Lbound( array ) /= LBound( grid%weights )\" , istart , LBound ( grid % weights , 1 ) ) if ( iend /= Ubound ( grid % weights , 1 ) ) & & call Error ( \"Integrate: Ubound( array ) /= UBound( grid%weights )\" , iend , UBound ( grid % weights , 1 ) ) integral = Sum ( grid % weights (:) * array (:) ) else ! no weights integral = Sum ( array ) ! weight with cell volume if ( Grid_has_cell ( grid ) ) then volume = Grid_volume ( grid ) integral = integral / volume end if end if else ! no grid integral = Sum ( array ) end if end function Integrate !!******************************************************************** !! Calculation of the volume of the cell associated with a given grid. !!******************************************************************** function Grid_volume ( grid ) result ( volume ) !! Input: grid, has to have a cell type ( grid_t ), intent ( in ) :: grid !! Output: the calculated volume real ( kind = DP ) :: volume !! Internal: cell real ( kind = DP ) :: cell ( 1 : 3 , 1 : 3 ) !! ! Calculation depends on the grid having weights, a cell or nothing if ( . not . Grid_has_cell ( grid ) ) & & call Error ( \"Grid_volume: Need a cell to calculate volume!\" ) cell ( 1 : 3 , 1 : 3 ) = grid % cell ( 1 : 3 , 1 : 3 ) volume = Dot_product ( Cross ( cell ( 1 , :), cell ( 2 , :) ), cell ( 3 , :) ) end function Grid_volume !!******************************************************************** !! Calculation of the cross product of two vectors !!******************************************************************** pure function Cross ( a , b ) result ( c ) !! Input: two 3D vectors real ( kind = DP ), intent ( in ) :: a ( 1 : 3 ), b ( 1 : 3 ) !! Output: one 3D vector real ( kind = DP ) :: c ( 1 : 3 ) !! c ( 1 ) = a ( 2 ) * b ( 3 ) - a ( 3 ) * b ( 2 ) c ( 2 ) = a ( 3 ) * b ( 1 ) - a ( 1 ) * b ( 3 ) c ( 3 ) = a ( 1 ) * b ( 2 ) - a ( 2 ) * b ( 1 ) end function Cross !!******************************************************************** !! Calculation of grid positions from cell vectors and grid points. !!******************************************************************** subroutine Grid_pos_from_cell ( grid ) !! Input: grid, has to have a cell type ( grid_t ), intent ( inout ) :: grid !! Internal: calculated positions real ( kind = DP ), allocatable :: positions (:, :) !! Internal: loop indices integer :: ix , iy , iz , ii !! ! Calculation depends on the grid having weights, a cell or nothing if ( . not . Grid_has_periodicity ( grid ) ) & & call Error ( \"Grid_pos_from_cell: Need a cell and points in each direction to calculate positions!\" ) allocate ( positions ( 1 : 3 , 1 : grid % ngpt ) ) ii = 0 !! @NOTE here, x is the fastest dimension, !! this is different for cube files, where z is fastest, !! thus, reading cubes and converting into our format will be slow @ENDNOTE do concurrent ( ix = 1 : grid % ngptx ) do concurrent ( iy = 1 : grid % ngpty ) do concurrent ( iz = 1 : grid % ngptz ) ii = ii + 1 positions (:, ii ) = ix * grid % cell ( 1 , :) + iy * grid % cell ( 2 , :) + iz * grid % cell ( 3 , :) end do end do end do call Grid_set_positions ( grid , positions ) deallocate ( positions ) end subroutine Grid_pos_from_cell !!******************************************************************** !! Interpolation of all functions in a molecule onto some grid. !! !! This subroutine interpolates density, gradient and nuclear potential !! of a molecule onto a given grid. !! An implementation of Shepards method is used. !!******************************************************************** subroutine Mol_interpolate ( molecule , ingrid ) !! Input: molecule, will be modified type ( molecule_t ), intent ( inout ) :: molecule !! Input: grid type ( grid_t ), intent ( in ) :: ingrid !! Internal: grid, because the input grid shall not be modified type ( grid_t ) :: grid !! Internal: number of grid points of given grid integer :: ngpt !! Internal: new / interpolated function values, size = ngpt real ( kind = DP ), allocatable :: newvalues (:) !! grid = ingrid ! Catch some errors if ( . not . Mol_has_grid ( molecule ) )& & call Error ( \"Mol_interpolate: Molecule has no grid!\" ) ! Can calculate positions from cell, if cell exists if ( . not . Grid_has_positions ( molecule % grid ) ) then if ( Grid_has_periodicity ( molecule % grid ) ) then call Grid_pos_from_cell ( molecule % grid ) else call Error ( \"Mol_interpolate: Molecule%grid has no positions!\" ) end if end if if ( . not . Grid_has_positions ( grid ) ) then if ( Grid_has_periodicity ( grid ) ) then call Grid_pos_from_cell ( grid ) else call Error ( \"Mol_interpolate: Grid has no positions!\" ) end if end if ! Set new grid points, so all the \"Mol_set\" later on works ! New values always have dimension of grid ngpt = grid % ngpt molecule % ngpt = ngpt allocate ( newvalues ( ngpt ) ) ! For spin polarized case, all the arrays are different sizes if ( molecule % spinpol ) then ! Interpolate density if ( Mol_has_density ( molecule ) ) then call Shepard_interpolate ( molecule % grid % positions , & & molecule % density ( 1 : ngpt ), grid % positions , newvalues ) call Mol_set_density_a ( molecule , newvalues ) call Shepard_interpolate ( molecule % grid % positions , & & molecule % density ( ngpt + 1 : 2 * ngpt ), grid % positions , newvalues ) call Mol_set_density_b ( molecule , newvalues ) endif ! Interpolate gradient if ( Mol_has_gradient ( molecule ) ) then call Shepard_interpolate ( molecule % grid % positions , & & molecule % gradient ( 1 : ngpt ), grid % positions , newvalues ) call Mol_set_gradient_aa ( molecule , newvalues ) call Shepard_interpolate ( molecule % grid % positions , & & molecule % gradient ( ngpt + 1 : 2 * ngpt ), grid % positions , newvalues ) call Mol_set_gradient_ab ( molecule , newvalues ) call Shepard_interpolate ( molecule % grid % positions , & & molecule % gradient ( 2 * ngpt + 1 : 3 * ngpt ), grid % positions , newvalues ) call Mol_set_gradient_bb ( molecule , newvalues ) endif else ! Interpolate density if ( Mol_has_density ( molecule ) ) then call Shepard_interpolate ( molecule % grid % positions , & & molecule % density , grid % positions , newvalues ) call Mol_set_density ( molecule , newvalues ) endif ! Interpolate gradient if ( Mol_has_gradient ( molecule ) ) then call Shepard_interpolate ( molecule % grid % positions , & & molecule % gradient , grid % positions , newvalues ) call Mol_set_gradient ( molecule , newvalues ) endif end if ! Interpolate nuclear potential, doesnt depend on spin if ( Mol_has_vnuc ( molecule ) ) then call Shepard_interpolate ( molecule % grid % positions , & & molecule % vnuc , grid % positions , newvalues ) call Mol_set_vnuc ( molecule , newvalues ) endif ! Finally, set molecular grid to new grid call Mol_set_grid ( molecule , grid ) end subroutine Mol_interpolate !!******************************************************************** !! Shepard interpolation of a 3D function f_j given on positions \\pmb{r}_{ref,j} !! onto a grid defined by positions \\pmb{r}_i. !! !! This is the basic, global Shepard method: !!  Q_i = \\frac{ \\sum_{j=1}&#94;{M} w_i(\\pmb{r}_{ref,j})\\cdot f_j }{ \\sum_{j=1}&#94;{M} w_i(\\pmb{r}_{ref,j}) }  !! with !!  w_i(\\pmb{r}_j) = \\frac{1}{d_{i,j}&#94;2}  !! and !!  d_{i,j}&#94;2 = |\\pmb{r}_i - \\pmb{r}_{ref,j}|&#94;2 .  !! !! ref_pos is \\pmb{r}_{ref,j}, ref_func is f_j, pos is \\pmb{r}_i and func is Q_i. !! !! Ref.: Shepard D (1968) A two-dimensional interpolation function for irregularly spaced data !!       Proc. 23rd Nat. Conf. ACM 517-523 Brandon/Systems Press Inc., Princeton !! DOI: [https://dx.doi.org/10.1145/800186.810616](https://dx.doi.org/10.1145/800186.810616) !! !! @NOTE Might need to rescale everything if the integral has to be the same! @ENDNOTE !!******************************************************************** subroutine Shepard_interpolate ( ref_pos , ref_func , pos , func ) !! Input: reference position and target position real ( kind = DP ), intent ( in ) :: ref_pos (:, :), pos (:, :) !! Input: reference function real ( kind = DP ), intent ( in ) :: ref_func (:) !! Output: interpolated function real ( kind = DP ), intent ( out ) :: func (:) !! Internal: start and end of reference function, start and end of result function, !! loop indices, index of zero distance integer :: ref_istart , ref_iend , istart , iend , i , j , izero !! Internal: sum w*f, sum w, one weight real ( kind = DP ) :: sum_func , sum_weights , weight !! ! Reference start and end index ref_istart = Lbound ( ref_func , 1 ) ref_iend = Ubound ( ref_func , 1 ) if ( ref_istart /= LBound ( ref_pos , 2 ) ) & & call Error ( \"Shepard_Interpolate: LBound( ref_func ) /= LBound( ref_pos )\" , ref_istart , LBound ( ref_pos , 2 ) ) if ( ref_iend /= UBound ( ref_pos , 2 ) ) & & call Error ( \"Shepard_Interpolate: UBound( ref_func ) /= UBound( ref_pos )\" , ref_iend , UBound ( ref_pos , 2 ) ) ! Result start and end index istart = Lbound ( func , 1 ) iend = Ubound ( func , 1 ) if ( istart /= LBound ( pos , 2 ) ) & & call Error ( \"Shepard_Interpolate: LBound( func ) /= LBound( pos )\" , istart , LBound ( pos , 2 ) ) if ( iend /= UBound ( pos , 2 ) ) & & call Error ( \"Shepard_Interpolate: UBound( func ) /= UBound( pos )\" , ref_iend , UBound ( pos , 2 ) ) !TODO add check for first dimension of positions !      if( istart /= LBound( pos, 2 ) ) & !         & call Error( \"Shepard_Interpolate: LBound( func ) /= LBound( pos )\", istart, LBound( pos, 2 ) ) ! Actual interpolation ! Loop over result grid RESULTS : do concurrent ( i = istart : iend ) sum_func = 0.0_DP sum_weights = 0.0_DP ! Loop over reference grid !TODO OpenMP stuff REFERENCES : do j = ref_istart , ref_iend weight = Sum ( ( pos (:, i ) - ref_pos (:, j ) ) ** 2 ) ! If grid point is known (i.e. distance is 0), just use that value ! There is no faster way to do this, i tried if ( weight <= 1.0E-6_DP ) then sum_func = ref_func ( j ) sum_weights = 1.0_DP exit end if weight = 1.0_DP / weight sum_func = sum_func + weight * ref_func ( j ) sum_weights = sum_weights + weight end do REFERENCES ! New value is quotient of sums func ( i ) = sum_func / sum_weights !TODO IEEE error handling? important maths here! end do RESULTS end subroutine Shepard_interpolate !!******************************************************************** !! In future, this will calculate gradients of some function on arbitrary grids !!******************************************************************** subroutine Gradient ( molecule ) ! Input: molecule, will be modifies type ( molecule_t ) :: molecule end subroutine Gradient end module Utils_mod","tags":"","loc":"sourcefile/utils_mod.f90.html"},{"title":"Xcpot_mod.F90 – PYREMB","text":"This file depends on sourcefile~~xcpot_mod.f90~~EfferentGraph sourcefile~xcpot_mod.f90 Xcpot_mod.F90 sourcefile~utils_mod.f90 Utils_mod.F90 sourcefile~xcpot_mod.f90->sourcefile~utils_mod.f90 sourcefile~output_mod.f90 Output_mod.F90 sourcefile~xcpot_mod.f90->sourcefile~output_mod.f90 sourcefile~precision_mod.f90 Precision_mod.F90 sourcefile~xcpot_mod.f90->sourcefile~precision_mod.f90 sourcefile~types_mod.f90 Types_mod.F90 sourcefile~xcpot_mod.f90->sourcefile~types_mod.f90 sourcefile~utils_mod.f90->sourcefile~output_mod.f90 sourcefile~utils_mod.f90->sourcefile~precision_mod.f90 sourcefile~utils_mod.f90->sourcefile~types_mod.f90 sourcefile~output_mod.f90->sourcefile~precision_mod.f90 sourcefile~types_mod.f90->sourcefile~output_mod.f90 sourcefile~types_mod.f90->sourcefile~precision_mod.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Files dependent on this one sourcefile~~xcpot_mod.f90~~AfferentGraph sourcefile~xcpot_mod.f90 Xcpot_mod.F90 sourcefile~test.f90 Test.F90 sourcefile~test.f90->sourcefile~xcpot_mod.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules Xcpot_mod Source Code Xcpot_mod.F90 Source Code module Xcpot_mod use Precision_mod use Output_mod use Types_mod use Utils_mod !TODO should contain integrate and gradient !use libxc wrappers #ifdef LIBXC use Xcpot_libxc_mod #endif !alternatively use xcfun wrappers #ifdef XCFUN use Xcpot_xcfun_mod #endif implicit none public :: Xc_energy , Xc_potential contains subroutine Xc_energy ( molecule , functional , energy ) type ( molecule_t ), intent ( in ) :: molecule character ( * ), intent ( in ) :: functional real ( kind = DP ), intent ( out ) :: energy !functional id, for exchange, correlation and kinetic in this order integer :: funcid !energy density real ( kind = DP ), allocatable :: enerdens (:) character (:), allocatable :: functype allocate ( enerdens ( 1 : molecule % ngpt ) ) enerdens (:) = 0.0_DP call Xc_parse ( functional , funcid , functype ) select case ( functype ) case ( \"LDA\" ) call Xc_ener ( funcid , molecule % ngpt , molecule % spinpol , enerdens , molecule % density ) case ( \"GGA\" ) if ( . not . Mol_has_gradient ( molecule ) ) call Gradient ( molecule ) call Xc_ener ( funcid , molecule % ngpt , molecule % spinpol , enerdens , molecule % density , molecule % gradient ) case default call Error ( \"Xc_energy: only LDA and GGA possible!\" ) end select energy = Integrate ( enerdens , molecule % grid ) deallocate ( enerdens ) end subroutine Xc_energy !exchange-correlation-kinetic potential for a molecule and a specified functional subroutine Xc_potential ( molecule , functional , potential ) type ( molecule_t ), intent ( in ) :: molecule character ( * ), intent ( in ) :: functional real ( kind = DP ), intent ( out ) :: potential (:) !functional id, for exchange, correlation and kinetic in this order integer :: funcid real ( kind = DP ), allocatable :: temppot (:) character (:), allocatable :: functype potential (:) = 0.0_DP call Xc_parse ( functional , funcid , functype ) select case ( functype ) case ( \"LDA\" ) call Xc_pot ( funcid , molecule % ngpt , molecule % spinpol , potential , molecule % density ) case ( \"GGA\" ) if ( . not . Mol_has_gradient ( molecule ) ) call Gradient ( molecule ) call Xc_pot ( funcid , molecule % ngpt , molecule % spinpol , potential , molecule % density , molecule % gradient ) case default call Error ( \"Xc_potential: only LDA and GGA possible!\" ) end select end subroutine Xc_potential end module Xcpot_mod","tags":"","loc":"sourcefile/xcpot_mod.f90.html"},{"title":"Xcpot_libxc_mod.F90 – PYREMB","text":"This file depends on sourcefile~~xcpot_libxc_mod.f90~~EfferentGraph sourcefile~xcpot_libxc_mod.f90 Xcpot_libxc_mod.F90 sourcefile~output_mod.f90 Output_mod.F90 sourcefile~xcpot_libxc_mod.f90->sourcefile~output_mod.f90 sourcefile~precision_mod.f90 Precision_mod.F90 sourcefile~xcpot_libxc_mod.f90->sourcefile~precision_mod.f90 sourcefile~output_mod.f90->sourcefile~precision_mod.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\n    is dependent upon another if the latter must be compiled before the former\n    can be. Contents Modules Xcpot_libxc_mod Source Code Xcpot_libxc_mod.F90 Source Code module Xcpot_libxc_mod use Precision_mod use Output_mod use Xc_f90_types_m use Xc_f90_lib_m implicit none private :: xcfunc , xcinfo , vmajor , vminor public :: Xc_ener , Xc_pot type ( xc_f90_pointer_t ) :: xcfunc type ( xc_f90_pointer_t ) :: xcinfo integer :: vmajor , vminor contains subroutine Xc_ener ( functional , ngpt , spinpol , enerdens , density , gradient ) !functional id, #grid points integer , intent ( in ) :: functional , ngpt logical , intent ( in ) :: spinpol real ( kind = DP ), intent ( in ) :: density (:) real ( kind = DP ), optional , intent ( in ) :: gradient (:) real ( kind = DP ), intent ( out ) :: enerdens (:) enerdens (:) = 0.0_DP !initialize functional if ( spinpol ) then call Xc_f90_func_init ( xcfunc , xcinfo , functional , XC_POLARIZED ) else call Xc_f90_func_init ( xcfunc , xcinfo , functional , XC_UNPOLARIZED ) endif select case ( Xc_f90_info_family ( xcinfo ) ) !lda, simple case ( XC_FAMILY_LDA ) call Xc_f90_lda_exc ( xcfunc , ngpt , density ( 1 ), enerdens ( 1 ) ) !gga, needs gradient, returns also de/dsigma, where sigma is gradrho*gradrho !needs some formula to yield the correct potential case ( XC_FAMILY_GGA ) if ( . not . Present ( gradient ) ) & call Error ( \"Xc_pot: GGA functional specified but no gradient given!\" ) call Xc_f90_gga_exc ( xcfunc , ngpt , density ( 1 ), gradient ( 1 ), enerdens ( 1 ) ) !all other cases are impossible case default call Error ( \"Xc_pot: only LDA and GGA possible!\" ) end select call Xc_f90_func_end ( xcfunc ) end subroutine Xc_ener subroutine Xc_pot ( functional , ngpt , spinpol , potential , density , gradient ) !functional id, #grid points integer , intent ( in ) :: functional , ngpt logical , intent ( in ) :: spinpol real ( kind = DP ), intent ( in ) :: density (:) real ( kind = DP ), optional , intent ( in ) :: gradient (:) real ( kind = DP ), intent ( out ) :: potential (:) !internal: de/dsigma in addition to de/drho real ( kind = DP ), allocatable :: vsigma (:) potential (:) = 0.0_DP !initialize functional if ( spinpol ) then call Xc_f90_func_init ( xcfunc , xcinfo , functional , XC_POLARIZED ) else call Xc_f90_func_init ( xcfunc , xcinfo , functional , XC_UNPOLARIZED ) endif select case ( Xc_f90_info_family ( xcinfo ) ) !lda, simple case ( XC_FAMILY_LDA ) call Xc_f90_lda_vxc ( xcfunc , ngpt , density ( 1 ), potential ( 1 ) ) !gga, needs gradient, returns also de/dsigma, where sigma is gradrho*gradrho !needs some formula to yield the correct potential case ( XC_FAMILY_GGA ) if ( . not . Present ( gradient ) ) & call Error ( \"Xc_pot: GGA functional specified but no gradient given!\" ) if ( spinpol ) then allocate ( vsigma ( 1 : 3 * ngpt ) ) else allocate ( vsigma ( 1 : ngpt ) ) endif call Xc_f90_gga_vxc ( xcfunc , ngpt , density ( 1 ), gradient ( 1 ), potential ( 1 ), vsigma ( 1 ) ) !TODO tatsächliche formel einsetzen? !entälht vermutlich NOCH MEHR GRADIENTEN deallocate ( vsigma ) !all other cases are impossible case default call Error ( \"Xc_pot: only LDA and GGA possible!\" ) end select call Xc_f90_func_end ( xcfunc ) end subroutine Xc_pot subroutine Xc_parse ( funcstring , funcid , functype ) character ( len =* ), intent ( in ) :: funcstring integer , intent ( out ) :: funcid character ( len = :), allocatable , intent ( out ) :: functype integer :: family funcid = Xc_f90_functional_get_number ( Trim ( funcstring ) ) family = Xc_f90_family_from_id ( funcid ) select case ( family ) case ( XC_FAMILY_LDA ) functype = \"LDA\" case ( XC_FAMILY_GGA ) functype = \"GGA\" case default functype = \"UNSUPPORTED\" end select end subroutine Xc_parse end module Xcpot_libxc_mod","tags":"","loc":"sourcefile/xcpot_libxc_mod.f90.html"},{"title":"grid_t – PYREMB ","text":"type, public :: grid_t Grid type, contains points, weights, cell and positions Inherited by type~~grid_t~~InheritedByGraph type~grid_t grid_t type~molecule_t molecule_t type~molecule_t->type~grid_t grid Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables ngpt ngptx ngpty ngptz weights cell positions Components Type Visibility Attributes Name Initial integer, public :: ngpt Number of grid points integer, public :: ngptx = -1.0_DP Number of grid points in each direction, for periodic cells integer, public :: ngpty = -1.0_DP Number of grid points in each direction, for periodic cells integer, public :: ngptz = -1.0_DP Number of grid points in each direction, for periodic cells real(kind=DP), public, allocatable :: weights (:) Weights; size = ngpt, optional real(kind=DP), public, allocatable :: cell (:,:) Cell vectors; size = (3, 3), optional real(kind=DP), public, allocatable :: positions (:,:) Positions; size = (3, ngpt), first index is x,y,z, optional","tags":"","loc":"type/grid_t.html"},{"title":"ions_t – PYREMB ","text":"type, public :: ions_t Ions type, contains number, charges and positions Inherited by type~~ions_t~~InheritedByGraph type~ions_t ions_t type~molecule_t molecule_t type~molecule_t->type~ions_t ions Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables nions charges positions Components Type Visibility Attributes Name Initial integer, public :: nions Number of ions real(kind=DP), public, allocatable :: charges (:) Charges; size = nions real(kind=DP), public, allocatable :: positions (:,:) Positions; size = (3, nions), first index is x,y,z","tags":"","loc":"type/ions_t.html"},{"title":"molecule_t – PYREMB ","text":"type, public :: molecule_t Molecule type, contains points, grid, density, nuclear potential and ions Inherits type~~molecule_t~~InheritsGraph type~molecule_t molecule_t type~ions_t ions_t type~molecule_t->type~ions_t ions type~grid_t grid_t type~molecule_t->type~grid_t grid Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\n    extends. Dashed arrows point from a derived type to the other\n    types it contains as a components, with a label listing the name(s) of\n    said component(s). Contents Variables ngpt grid density gradient vnuc ions spinpol active Components Type Visibility Attributes Name Initial integer, public :: ngpt Number of grid points type( grid_t ), public, pointer :: grid => null() Grid, may contain weights, cell and positions real(kind=DP), public, allocatable :: density (:) Electron density; size = ngpt for unpolarized or 2 * ngpt for spin polarized, beta is from ngpt + 1:2 * ngpt real(kind=DP), public, allocatable :: gradient (:) Density gradient |\\nabla\\rho|&#94;2 ; size = npgt for unpolarized or 3 * ngpt for spin polarized, order is aa,ab,bb real(kind=DP), public, allocatable :: vnuc (:) Nuclear potential; size = ngpt, alternative to ions type( ions_t ), public, pointer :: ions => null() Ions, contains number of ions, charges and positions logical, public :: spinpol = .false. Spin polarized or not logical, public :: active = .false. Active or not","tags":"","loc":"type/molecule_t.html"},{"title":"Error – PYREMB","text":"public subroutine Error(string, int1, int2, real1, real2) Throw an Error determined by a string, print some numbers and \n exit with non-zero status Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string Input: string describing the error integer, intent(in), optional :: int1 Input: integers to print out, optional integer, intent(in), optional :: int2 Input: integers to print out, optional real(kind=DP), intent(in), optional :: real1 Input: floats to print out, optional real(kind=DP), intent(in), optional :: real2 Input: floats to print out, optional Called by proc~~error~~CalledByGraph proc~error Error proc~xc_ener Xc_ener proc~xc_ener->proc~error proc~grid_set_cell Grid_set_cell proc~grid_set_cell->proc~error proc~xc_potential Xc_potential proc~xc_potential->proc~error proc~embedding_energy Embedding_energy proc~embedding_energy->proc~error proc~mol_interpolate Mol_interpolate proc~embedding_energy->proc~mol_interpolate proc~mol_interpolate->proc~error proc~embedding_potential Embedding_potential proc~embedding_potential->proc~error proc~embedding_potential->proc~mol_interpolate proc~xc_pot Xc_pot proc~xc_pot->proc~error proc~xc_energy Xc_energy proc~xc_energy->proc~error proc~mol_init_grid Mol_init_grid proc~mol_init_grid->proc~grid_set_cell program~test Test program~test->proc~xc_potential program~test->proc~xc_energy program~test->proc~mol_init_grid Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/error.html"},{"title":"Warning – PYREMB","text":"public subroutine Warning(string, int1, int2, real1, real2) Throw a Warnig determined by a string, print some numbers, but\n do not exit Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string Input: string describing the error integer, intent(in), optional :: int1 Input: integers to print out, optional integer, intent(in), optional :: int2 Input: integers to print out, optional real(kind=DP), intent(in), optional :: real1 Input: floats to print out, optional real(kind=DP), intent(in), optional :: real2 Input: floats to print out, optional Called by proc~~warning~~CalledByGraph proc~warning Warning proc~mol_set_spin Mol_set_spin proc~mol_set_spin->proc~warning program~test Test program~test->proc~mol_set_spin Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/warning.html"},{"title":"Embedding_potential – PYREMB","text":"public subroutine Embedding_potential(x_func, c_func, k_func, potential) Calculation of embedding potential for the global system. Only needs eXchange, Correlation and Kinetic functionals as input\n and returns the effective embedding potential Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: x_func Input: exchange functional character(len=*), intent(in) :: c_func Input: correlation functional character(len=*), intent(in) :: k_func Input: kinetic functional real(kind=DP), intent(out) :: potential (:) Output: embedding potential Calls proc~~embedding_potential~~CallsGraph proc~embedding_potential Embedding_potential proc~error Error proc~embedding_potential->proc~error mol_has_vnuc mol_has_vnuc proc~embedding_potential->mol_has_vnuc proc~mol_interpolate Mol_interpolate proc~embedding_potential->proc~mol_interpolate xc_potential xc_potential proc~embedding_potential->xc_potential mol_set_density mol_set_density proc~embedding_potential->mol_set_density proc~mol_interpolate->proc~error proc~grid_has_periodicity Grid_has_periodicity proc~mol_interpolate->proc~grid_has_periodicity proc~mol_set_density Mol_set_density proc~mol_interpolate->proc~mol_set_density proc~mol_set_gradient_aa Mol_set_gradient_aa proc~mol_interpolate->proc~mol_set_gradient_aa proc~shepard_interpolate Shepard_interpolate proc~mol_interpolate->proc~shepard_interpolate proc~grid_has_positions Grid_has_positions proc~mol_interpolate->proc~grid_has_positions proc~mol_has_density Mol_has_density proc~mol_interpolate->proc~mol_has_density proc~mol_set_gradient_ab Mol_set_gradient_ab proc~mol_interpolate->proc~mol_set_gradient_ab proc~mol_set_density_a Mol_set_density_a proc~mol_interpolate->proc~mol_set_density_a proc~mol_set_gradient_bb Mol_set_gradient_bb proc~mol_interpolate->proc~mol_set_gradient_bb proc~mol_has_gradient Mol_has_gradient proc~mol_interpolate->proc~mol_has_gradient proc~mol_set_density_b Mol_set_density_b proc~mol_interpolate->proc~mol_set_density_b proc~mol_set_vnuc Mol_set_vnuc proc~mol_interpolate->proc~mol_set_vnuc proc~mol_set_gradient Mol_set_gradient proc~mol_interpolate->proc~mol_set_gradient proc~mol_set_grid Mol_set_grid proc~mol_interpolate->proc~mol_set_grid proc~grid_pos_from_cell Grid_pos_from_cell proc~mol_interpolate->proc~grid_pos_from_cell proc~mol_has_grid Mol_has_grid proc~mol_interpolate->proc~mol_has_grid proc~mol_has_vnuc Mol_has_vnuc proc~mol_interpolate->proc~mol_has_vnuc proc~grid_has_points_xyz Grid_has_points_xyz proc~grid_has_periodicity->proc~grid_has_points_xyz proc~grid_has_cell Grid_has_cell proc~grid_has_periodicity->proc~grid_has_cell proc~mol_set_density->proc~mol_has_density proc~mol_set_gradient_aa->proc~mol_has_gradient proc~mol_set_gradient_ab->proc~mol_has_gradient proc~mol_set_density_a->proc~mol_has_density proc~mol_set_gradient_bb->proc~mol_has_gradient proc~mol_set_density_b->proc~mol_has_density proc~mol_set_vnuc->proc~mol_has_vnuc proc~mol_set_gradient->proc~mol_has_gradient proc~mol_set_grid->proc~mol_has_grid proc~grid_pos_from_cell->proc~grid_has_periodicity proc~grid_set_positions Grid_set_positions proc~grid_pos_from_cell->proc~grid_set_positions proc~grid_set_positions->proc~grid_has_positions var panprocembedding_potentialCallsGraph = svgPanZoom('#procembedding_potentialCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/embedding_potential.html"},{"title":"Embedding_energy – PYREMB","text":"public subroutine Embedding_energy(x_func, c_func, k_func, energy) Calculation of embedding energy for the global system. Only needs eXchange, Correlation and Kinetic functionals as input\n and returns the effective embedding energy on the active grid Todo calculate energy on a common supergrid Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: x_func Input: exchange functional character(len=*), intent(in) :: c_func Input: correlation functional character(len=*), intent(in) :: k_func Input: kinetic functional real(kind=DP), intent(out) :: energy Output: embedding potential Calls proc~~embedding_energy~~CallsGraph proc~embedding_energy Embedding_energy proc~error Error proc~embedding_energy->proc~error mol_has_vnuc mol_has_vnuc proc~embedding_energy->mol_has_vnuc xc_energy xc_energy proc~embedding_energy->xc_energy proc~mol_interpolate Mol_interpolate proc~embedding_energy->proc~mol_interpolate mol_set_vnuc mol_set_vnuc proc~embedding_energy->mol_set_vnuc mol_set_density mol_set_density proc~embedding_energy->mol_set_density proc~integrate Integrate proc~embedding_energy->proc~integrate proc~mol_interpolate->proc~error proc~grid_has_periodicity Grid_has_periodicity proc~mol_interpolate->proc~grid_has_periodicity proc~mol_set_density Mol_set_density proc~mol_interpolate->proc~mol_set_density proc~mol_set_gradient_aa Mol_set_gradient_aa proc~mol_interpolate->proc~mol_set_gradient_aa proc~shepard_interpolate Shepard_interpolate proc~mol_interpolate->proc~shepard_interpolate proc~grid_has_positions Grid_has_positions proc~mol_interpolate->proc~grid_has_positions proc~mol_has_density Mol_has_density proc~mol_interpolate->proc~mol_has_density proc~mol_set_gradient_ab Mol_set_gradient_ab proc~mol_interpolate->proc~mol_set_gradient_ab proc~mol_set_density_a Mol_set_density_a proc~mol_interpolate->proc~mol_set_density_a proc~mol_set_gradient_bb Mol_set_gradient_bb proc~mol_interpolate->proc~mol_set_gradient_bb proc~mol_has_gradient Mol_has_gradient proc~mol_interpolate->proc~mol_has_gradient proc~mol_set_density_b Mol_set_density_b proc~mol_interpolate->proc~mol_set_density_b proc~mol_set_vnuc Mol_set_vnuc proc~mol_interpolate->proc~mol_set_vnuc proc~mol_set_gradient Mol_set_gradient proc~mol_interpolate->proc~mol_set_gradient proc~mol_set_grid Mol_set_grid proc~mol_interpolate->proc~mol_set_grid proc~grid_pos_from_cell Grid_pos_from_cell proc~mol_interpolate->proc~grid_pos_from_cell proc~mol_has_grid Mol_has_grid proc~mol_interpolate->proc~mol_has_grid proc~mol_has_vnuc Mol_has_vnuc proc~mol_interpolate->proc~mol_has_vnuc proc~grid_volume Grid_volume proc~integrate->proc~grid_volume proc~grid_has_cell Grid_has_cell proc~integrate->proc~grid_has_cell proc~grid_has_weights Grid_has_weights proc~integrate->proc~grid_has_weights proc~grid_has_periodicity->proc~grid_has_cell proc~grid_has_points_xyz Grid_has_points_xyz proc~grid_has_periodicity->proc~grid_has_points_xyz proc~mol_set_density->proc~mol_has_density proc~mol_set_gradient_aa->proc~mol_has_gradient proc~grid_volume->proc~grid_has_cell proc~cross Cross proc~grid_volume->proc~cross proc~mol_set_gradient_ab->proc~mol_has_gradient proc~mol_set_density_a->proc~mol_has_density proc~mol_set_gradient_bb->proc~mol_has_gradient proc~mol_set_density_b->proc~mol_has_density proc~mol_set_vnuc->proc~mol_has_vnuc proc~mol_set_gradient->proc~mol_has_gradient proc~mol_set_grid->proc~mol_has_grid proc~grid_pos_from_cell->proc~grid_has_periodicity proc~grid_set_positions Grid_set_positions proc~grid_pos_from_cell->proc~grid_set_positions proc~grid_set_positions->proc~grid_has_positions var panprocembedding_energyCallsGraph = svgPanZoom('#procembedding_energyCallsGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/embedding_energy.html"},{"title":"Init – PYREMB","text":"public subroutine Init(numsys) Basic initialization of the system, not specifying any molecules Arguments Type Intent Optional Attributes Name integer, intent(in) :: numsys Input: number of subsystems Contents None","tags":"","loc":"proc/init.html"},{"title":"Sys_init – PYREMB","text":"public subroutine Sys_init(subsystem, density, vnuc, gridweights, gridpositions, active, spin) Initialize a subsystem, optionally with all important parameters. Arguments Type Intent Optional Attributes Name integer, intent(in) :: subsystem Input: index of the subsystem real(kind=DP), intent(in) :: density (:) Input: density, 1D array of length ngpt (or 2*ngpt if spin polarized; order is a, b) real(kind=DP), intent(in), optional :: vnuc (:) Input: nuclear potential, of length ngpt real(kind=DP), intent(in), optional :: gridweights (:) Input: grid weights, length ngpt real(kind=DP), intent(in), optional :: gridpositions (:,:) Input: grid positions, length (3,ngpt) logical, intent(in), optional :: active Input: whether the system is active logical, intent(in), optional :: spin Input: whether the system is spin polarized Called by proc~~sys_init~~CalledByGraph proc~sys_init Sys_init program~test Test program~test->proc~sys_init Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/sys_init.html"},{"title":"Mol_has_grid – PYREMB","text":"public pure function Mol_has_grid(this) result(hasgrid) Return .true. if the molecule has a grid. Arguments Type Intent Optional Attributes Name type( molecule_t ), intent(in) :: this Input: molecule Return Value logical Output: whether the molecule has a grid Called by proc~~mol_has_grid~~CalledByGraph proc~mol_has_grid Mol_has_grid program~test Test program~test->proc~mol_has_grid proc~mol_init_grid Mol_init_grid program~test->proc~mol_init_grid proc~mol_set_grid Mol_set_grid program~test->proc~mol_set_grid proc~mol_interpolate Mol_interpolate proc~mol_interpolate->proc~mol_has_grid proc~mol_interpolate->proc~mol_set_grid proc~mol_init_grid->proc~mol_has_grid proc~mol_set_grid->proc~mol_has_grid proc~embedding_energy Embedding_energy proc~embedding_energy->proc~mol_interpolate proc~embedding_potential Embedding_potential proc~embedding_potential->proc~mol_interpolate Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/mol_has_grid.html"},{"title":"Mol_has_vnuc – PYREMB","text":"public pure function Mol_has_vnuc(this) result(hasvnuc) Return .true. if the molecule has a vnuc (nuclear potential). Arguments Type Intent Optional Attributes Name type( molecule_t ), intent(in) :: this Input: molecule Return Value logical Output: whether the molecule has a vnuc Called by proc~~mol_has_vnuc~~CalledByGraph proc~mol_has_vnuc Mol_has_vnuc proc~mol_set_vnuc Mol_set_vnuc proc~mol_set_vnuc->proc~mol_has_vnuc proc~mol_interpolate Mol_interpolate proc~mol_interpolate->proc~mol_has_vnuc proc~mol_interpolate->proc~mol_set_vnuc program~test Test program~test->proc~mol_has_vnuc program~test->proc~mol_set_vnuc proc~embedding_energy Embedding_energy proc~embedding_energy->proc~mol_interpolate proc~embedding_potential Embedding_potential proc~embedding_potential->proc~mol_interpolate Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/mol_has_vnuc.html"},{"title":"Mol_has_ions – PYREMB","text":"public pure function Mol_has_ions(this) result(hasions) Return .true. if the molecule has ions. Arguments Type Intent Optional Attributes Name type( molecule_t ), intent(in) :: this Input: molecule Return Value logical Output: whether the molecule has ions Called by proc~~mol_has_ions~~CalledByGraph proc~mol_has_ions Mol_has_ions proc~mol_set_ions Mol_set_ions proc~mol_set_ions->proc~mol_has_ions proc~mol_init_ions Mol_init_ions proc~mol_init_ions->proc~mol_has_ions program~test Test program~test->proc~mol_has_ions program~test->proc~mol_set_ions program~test->proc~mol_init_ions Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/mol_has_ions.html"},{"title":"Mol_has_density – PYREMB","text":"public pure function Mol_has_density(this) result(hasdensity) Return .true. if the molecule has a density. Arguments Type Intent Optional Attributes Name type( molecule_t ), intent(in) :: this Input: molecule Return Value logical Output: whether the molecule has a density Called by proc~~mol_has_density~~CalledByGraph proc~mol_has_density Mol_has_density proc~mol_set_density Mol_set_density proc~mol_set_density->proc~mol_has_density proc~mol_set_spin Mol_set_spin proc~mol_set_spin->proc~mol_has_density proc~mol_interpolate Mol_interpolate proc~mol_interpolate->proc~mol_has_density proc~mol_interpolate->proc~mol_set_density proc~mol_set_density_a Mol_set_density_a proc~mol_interpolate->proc~mol_set_density_a proc~mol_set_density_b Mol_set_density_b proc~mol_interpolate->proc~mol_set_density_b proc~mol_set_density_a->proc~mol_has_density proc~mol_set_density_b->proc~mol_has_density program~test Test program~test->proc~mol_has_density program~test->proc~mol_set_density program~test->proc~mol_set_spin proc~embedding_energy Embedding_energy proc~embedding_energy->proc~mol_interpolate proc~embedding_potential Embedding_potential proc~embedding_potential->proc~mol_interpolate Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/mol_has_density.html"},{"title":"Mol_has_gradient – PYREMB","text":"public pure function Mol_has_gradient(this) result(hasgradient) Return .true. if the molecule has a density gradient. Arguments Type Intent Optional Attributes Name type( molecule_t ), intent(in) :: this Input: molecule Return Value logical Output: whether the molecule has a gradient Called by proc~~mol_has_gradient~~CalledByGraph proc~mol_has_gradient Mol_has_gradient proc~xc_potential Xc_potential proc~xc_potential->proc~mol_has_gradient proc~mol_set_gradient_aa Mol_set_gradient_aa proc~mol_set_gradient_aa->proc~mol_has_gradient proc~mol_set_spin Mol_set_spin proc~mol_set_spin->proc~mol_has_gradient proc~mol_set_gradient_ab Mol_set_gradient_ab proc~mol_set_gradient_ab->proc~mol_has_gradient proc~mol_interpolate Mol_interpolate proc~mol_interpolate->proc~mol_has_gradient proc~mol_interpolate->proc~mol_set_gradient_aa proc~mol_interpolate->proc~mol_set_gradient_ab proc~mol_set_gradient_bb Mol_set_gradient_bb proc~mol_interpolate->proc~mol_set_gradient_bb proc~mol_set_gradient Mol_set_gradient proc~mol_interpolate->proc~mol_set_gradient proc~mol_set_gradient_bb->proc~mol_has_gradient proc~mol_set_gradient->proc~mol_has_gradient program~test Test program~test->proc~mol_has_gradient program~test->proc~xc_potential program~test->proc~mol_set_spin program~test->proc~mol_set_gradient proc~xc_energy Xc_energy program~test->proc~xc_energy proc~xc_energy->proc~mol_has_gradient proc~embedding_energy Embedding_energy proc~embedding_energy->proc~mol_interpolate proc~embedding_potential Embedding_potential proc~embedding_potential->proc~mol_interpolate Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/mol_has_gradient.html"},{"title":"Grid_has_weights – PYREMB","text":"public pure function Grid_has_weights(this) result(hasweights) Return .true. if the grid has weights. Arguments Type Intent Optional Attributes Name type( grid_t ), intent(in) :: this Input: grid Return Value logical Output: whether the grid has weights Called by proc~~grid_has_weights~~CalledByGraph proc~grid_has_weights Grid_has_weights proc~grid_set_weights Grid_set_weights proc~grid_set_weights->proc~grid_has_weights proc~integrate Integrate proc~integrate->proc~grid_has_weights proc~embedding_energy Embedding_energy proc~embedding_energy->proc~integrate proc~mol_init_grid Mol_init_grid proc~mol_init_grid->proc~grid_set_weights proc~xc_energy Xc_energy proc~xc_energy->proc~integrate program~test Test program~test->proc~integrate program~test->proc~mol_init_grid program~test->proc~xc_energy Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/grid_has_weights.html"},{"title":"Grid_has_cell – PYREMB","text":"public pure function Grid_has_cell(this) result(hascell) Return .true. if the grid has a cell. Arguments Type Intent Optional Attributes Name type( grid_t ), intent(in) :: this Input: grid Return Value logical Output: whether the grid has a cell Called by proc~~grid_has_cell~~CalledByGraph proc~grid_has_cell Grid_has_cell proc~grid_has_periodicity Grid_has_periodicity proc~grid_has_periodicity->proc~grid_has_cell proc~grid_set_cell Grid_set_cell proc~grid_set_cell->proc~grid_has_cell proc~integrate Integrate proc~integrate->proc~grid_has_cell proc~grid_volume Grid_volume proc~integrate->proc~grid_volume proc~grid_volume->proc~grid_has_cell proc~mol_init_grid Mol_init_grid proc~mol_init_grid->proc~grid_set_cell proc~embedding_energy Embedding_energy proc~embedding_energy->proc~integrate proc~mol_interpolate Mol_interpolate proc~embedding_energy->proc~mol_interpolate proc~mol_interpolate->proc~grid_has_periodicity proc~grid_pos_from_cell Grid_pos_from_cell proc~mol_interpolate->proc~grid_pos_from_cell proc~grid_pos_from_cell->proc~grid_has_periodicity program~test Test program~test->proc~integrate program~test->proc~mol_init_grid proc~xc_energy Xc_energy program~test->proc~xc_energy proc~xc_energy->proc~integrate proc~embedding_potential Embedding_potential proc~embedding_potential->proc~mol_interpolate var panprocgrid_has_cellCalledByGraph = svgPanZoom('#procgrid_has_cellCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/grid_has_cell.html"},{"title":"Grid_has_positions – PYREMB","text":"public pure function Grid_has_positions(this) result(haspositions) Return .true. if the grid has positions. Arguments Type Intent Optional Attributes Name type( grid_t ), intent(in) :: this Input: grid Return Value logical Output: whether the grid has a cell Called by proc~~grid_has_positions~~CalledByGraph proc~grid_has_positions Grid_has_positions proc~grid_set_positions Grid_set_positions proc~grid_set_positions->proc~grid_has_positions proc~mol_interpolate Mol_interpolate proc~mol_interpolate->proc~grid_has_positions proc~grid_pos_from_cell Grid_pos_from_cell proc~mol_interpolate->proc~grid_pos_from_cell proc~embedding_energy Embedding_energy proc~embedding_energy->proc~mol_interpolate proc~embedding_potential Embedding_potential proc~embedding_potential->proc~mol_interpolate proc~mol_init_grid Mol_init_grid proc~mol_init_grid->proc~grid_set_positions proc~grid_pos_from_cell->proc~grid_set_positions program~test Test program~test->proc~mol_init_grid var panprocgrid_has_positionsCalledByGraph = svgPanZoom('#procgrid_has_positionsCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/grid_has_positions.html"},{"title":"Grid_has_points_xyz – PYREMB","text":"public pure function Grid_has_points_xyz(this) result(haspointsxyz) Return .true. if the grid has points for all directions Arguments Type Intent Optional Attributes Name type( grid_t ), intent(in) :: this Input: grid Return Value logical Output: whether the grid has points for all directions Called by proc~~grid_has_points_xyz~~CalledByGraph proc~grid_has_points_xyz Grid_has_points_xyz proc~grid_has_periodicity Grid_has_periodicity proc~grid_has_periodicity->proc~grid_has_points_xyz proc~mol_interpolate Mol_interpolate proc~mol_interpolate->proc~grid_has_periodicity proc~grid_pos_from_cell Grid_pos_from_cell proc~mol_interpolate->proc~grid_pos_from_cell proc~grid_pos_from_cell->proc~grid_has_periodicity proc~embedding_energy Embedding_energy proc~embedding_energy->proc~mol_interpolate proc~embedding_potential Embedding_potential proc~embedding_potential->proc~mol_interpolate var panprocgrid_has_points_xyzCalledByGraph = svgPanZoom('#procgrid_has_points_xyzCalledByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/grid_has_points_xyz.html"},{"title":"Grid_has_periodicity – PYREMB","text":"public pure function Grid_has_periodicity(this) result(hasperiodicity) Return .true. if the grid has all properties associated with periodicity Arguments Type Intent Optional Attributes Name type( grid_t ), intent(in) :: this Input: grid Return Value logical Output: whether the grid has all properties associated with periodicity Calls proc~~grid_has_periodicity~~CallsGraph proc~grid_has_periodicity Grid_has_periodicity proc~grid_has_points_xyz Grid_has_points_xyz proc~grid_has_periodicity->proc~grid_has_points_xyz proc~grid_has_cell Grid_has_cell proc~grid_has_periodicity->proc~grid_has_cell Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~grid_has_periodicity~~CalledByGraph proc~grid_has_periodicity Grid_has_periodicity proc~mol_interpolate Mol_interpolate proc~mol_interpolate->proc~grid_has_periodicity proc~grid_pos_from_cell Grid_pos_from_cell proc~mol_interpolate->proc~grid_pos_from_cell proc~grid_pos_from_cell->proc~grid_has_periodicity proc~embedding_energy Embedding_energy proc~embedding_energy->proc~mol_interpolate proc~embedding_potential Embedding_potential proc~embedding_potential->proc~mol_interpolate Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/grid_has_periodicity.html"},{"title":"Ions_has_charges – PYREMB","text":"public pure function Ions_has_charges(this) result(hascharges) Return .true. if the ions have charges. \n Even though ions should always be initialized with charges, it is not impossible to not have charges. Arguments Type Intent Optional Attributes Name type( ions_t ), intent(in) :: this Input: ions Return Value logical Output: whether the ions have charges Called by proc~~ions_has_charges~~CalledByGraph proc~ions_has_charges Ions_has_charges proc~ions_set_charges Ions_set_charges proc~ions_set_charges->proc~ions_has_charges program~test Test program~test->proc~ions_has_charges proc~mol_init_ions Mol_init_ions program~test->proc~mol_init_ions proc~mol_init_ions->proc~ions_set_charges Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/ions_has_charges.html"},{"title":"Ions_has_positions – PYREMB","text":"public pure function Ions_has_positions(this) result(haspositions) Return .true. if the ions have positions. \n Even though ions should always be initialized with positions, it is not impossible to not have positions. Arguments Type Intent Optional Attributes Name type( ions_t ), intent(in) :: this Input: ions Return Value logical Output: whether the ions have positions Called by proc~~ions_has_positions~~CalledByGraph proc~ions_has_positions Ions_has_positions proc~ions_set_positions Ions_set_positions proc~ions_set_positions->proc~ions_has_positions proc~mol_init_ions Mol_init_ions proc~mol_init_ions->proc~ions_set_positions program~test Test program~test->proc~mol_init_ions Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/ions_has_positions.html"},{"title":"Mol_set_grid – PYREMB","text":"public subroutine Mol_set_grid(this, grid) Set the grid of a molecule. Initialize a grid if none exists. Arguments Type Intent Optional Attributes Name type( molecule_t ), intent(inout) :: this Input: molecule type( grid_t ), intent(in) :: grid Input: grid, ngpt has to be ngpt of molecule Calls proc~~mol_set_grid~~CallsGraph proc~mol_set_grid Mol_set_grid proc~mol_has_grid Mol_has_grid proc~mol_set_grid->proc~mol_has_grid Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~mol_set_grid~~CalledByGraph proc~mol_set_grid Mol_set_grid proc~mol_interpolate Mol_interpolate proc~mol_interpolate->proc~mol_set_grid program~test Test program~test->proc~mol_set_grid proc~embedding_energy Embedding_energy proc~embedding_energy->proc~mol_interpolate proc~embedding_potential Embedding_potential proc~embedding_potential->proc~mol_interpolate Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/mol_set_grid.html"},{"title":"Mol_set_vnuc – PYREMB","text":"public subroutine Mol_set_vnuc(this, vnuc) Set the nuclear potential of a molecule. Initialize one if none exists. Arguments Type Intent Optional Attributes Name type( molecule_t ), intent(inout) :: this Input: molecule real(kind=DP), intent(in) :: vnuc (:) Input: nuclear potential, 1D array of size ngpt Calls proc~~mol_set_vnuc~~CallsGraph proc~mol_set_vnuc Mol_set_vnuc proc~mol_has_vnuc Mol_has_vnuc proc~mol_set_vnuc->proc~mol_has_vnuc Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~mol_set_vnuc~~CalledByGraph proc~mol_set_vnuc Mol_set_vnuc proc~mol_interpolate Mol_interpolate proc~mol_interpolate->proc~mol_set_vnuc program~test Test program~test->proc~mol_set_vnuc proc~embedding_energy Embedding_energy proc~embedding_energy->proc~mol_interpolate proc~embedding_potential Embedding_potential proc~embedding_potential->proc~mol_interpolate Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/mol_set_vnuc.html"},{"title":"Mol_set_ions – PYREMB","text":"public pure subroutine Mol_set_ions(this, ions) Set the ions of a molecule. Initialize if none exist. Arguments Type Intent Optional Attributes Name type( molecule_t ), intent(inout) :: this Input: molecule type( ions_t ), intent(in) :: ions Input: ions Calls proc~~mol_set_ions~~CallsGraph proc~mol_set_ions Mol_set_ions proc~mol_has_ions Mol_has_ions proc~mol_set_ions->proc~mol_has_ions Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~mol_set_ions~~CalledByGraph proc~mol_set_ions Mol_set_ions program~test Test program~test->proc~mol_set_ions Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/mol_set_ions.html"},{"title":"Mol_set_spin – PYREMB","text":"public subroutine Mol_set_spin(this, spinpol) Set the spin of a molecule. If density or gradient exist, they are deallocated! Arguments Type Intent Optional Attributes Name type( molecule_t ), intent(inout) :: this Input: molecule logical, intent(in) :: spinpol Input: spin ( .true. = spin polarized, .false. = unpolarized ) Calls proc~~mol_set_spin~~CallsGraph proc~mol_set_spin Mol_set_spin proc~mol_has_gradient Mol_has_gradient proc~mol_set_spin->proc~mol_has_gradient proc~warning Warning proc~mol_set_spin->proc~warning proc~mol_has_density Mol_has_density proc~mol_set_spin->proc~mol_has_density Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~mol_set_spin~~CalledByGraph proc~mol_set_spin Mol_set_spin program~test Test program~test->proc~mol_set_spin Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/mol_set_spin.html"},{"title":"Mol_set_density – PYREMB","text":"public subroutine Mol_set_density(this, density) Set the density of a molecule. Initialize density if none exists. Arguments Type Intent Optional Attributes Name type( molecule_t ), intent(inout) :: this Input: molecule real(kind=DP), intent(in) :: density (:) Input: density, 1D array of length ngpt (or 2*ngpt if spin polarized; order is a, b) Calls proc~~mol_set_density~~CallsGraph proc~mol_set_density Mol_set_density proc~mol_has_density Mol_has_density proc~mol_set_density->proc~mol_has_density Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~mol_set_density~~CalledByGraph proc~mol_set_density Mol_set_density proc~mol_interpolate Mol_interpolate proc~mol_interpolate->proc~mol_set_density program~test Test program~test->proc~mol_set_density proc~embedding_energy Embedding_energy proc~embedding_energy->proc~mol_interpolate proc~embedding_potential Embedding_potential proc~embedding_potential->proc~mol_interpolate Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/mol_set_density.html"},{"title":"Mol_set_density_a – PYREMB","text":"public subroutine Mol_set_density_a(this, density) Set the alpha spin density of a molecule. Initialize density if none exists. Arguments Type Intent Optional Attributes Name type( molecule_t ), intent(inout) :: this Input: molecule real(kind=DP), intent(in) :: density (:) Input: density, 1D array of length ngpt Calls proc~~mol_set_density_a~~CallsGraph proc~mol_set_density_a Mol_set_density_a proc~mol_has_density Mol_has_density proc~mol_set_density_a->proc~mol_has_density Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~mol_set_density_a~~CalledByGraph proc~mol_set_density_a Mol_set_density_a proc~mol_interpolate Mol_interpolate proc~mol_interpolate->proc~mol_set_density_a proc~embedding_energy Embedding_energy proc~embedding_energy->proc~mol_interpolate proc~embedding_potential Embedding_potential proc~embedding_potential->proc~mol_interpolate Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/mol_set_density_a.html"},{"title":"Mol_set_density_b – PYREMB","text":"public subroutine Mol_set_density_b(this, density) Set the beta spin density of a molecule. Initialize density if none exists. Arguments Type Intent Optional Attributes Name type( molecule_t ), intent(inout) :: this Input: molecule real(kind=DP), intent(in) :: density (:) Input: density, 1D array of length ngpt Calls proc~~mol_set_density_b~~CallsGraph proc~mol_set_density_b Mol_set_density_b proc~mol_has_density Mol_has_density proc~mol_set_density_b->proc~mol_has_density Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~mol_set_density_b~~CalledByGraph proc~mol_set_density_b Mol_set_density_b proc~mol_interpolate Mol_interpolate proc~mol_interpolate->proc~mol_set_density_b proc~embedding_energy Embedding_energy proc~embedding_energy->proc~mol_interpolate proc~embedding_potential Embedding_potential proc~embedding_potential->proc~mol_interpolate Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/mol_set_density_b.html"},{"title":"Mol_set_gradient – PYREMB","text":"public subroutine Mol_set_gradient(this, gradient) Set the density gradient of a molecule. Initialize gradient if none exists. Arguments Type Intent Optional Attributes Name type( molecule_t ), intent(inout) :: this Input: molecule real(kind=DP), intent(in) :: gradient (:) Input: gradient, 1D array of length ngpt (3* ngpt if spin polarized; order is aa, ab, bb) Calls proc~~mol_set_gradient~~CallsGraph proc~mol_set_gradient Mol_set_gradient proc~mol_has_gradient Mol_has_gradient proc~mol_set_gradient->proc~mol_has_gradient Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~mol_set_gradient~~CalledByGraph proc~mol_set_gradient Mol_set_gradient proc~mol_interpolate Mol_interpolate proc~mol_interpolate->proc~mol_set_gradient program~test Test program~test->proc~mol_set_gradient proc~embedding_energy Embedding_energy proc~embedding_energy->proc~mol_interpolate proc~embedding_potential Embedding_potential proc~embedding_potential->proc~mol_interpolate Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/mol_set_gradient.html"},{"title":"Mol_set_gradient_aa – PYREMB","text":"public subroutine Mol_set_gradient_aa(this, gradient) Set the aa density gradient of a molecule. Initialize gradient if none exists. Arguments Type Intent Optional Attributes Name type( molecule_t ), intent(inout) :: this Input: molecule real(kind=DP), intent(in) :: gradient (:) Input: gradient, 1D array of length ngpt Calls proc~~mol_set_gradient_aa~~CallsGraph proc~mol_set_gradient_aa Mol_set_gradient_aa proc~mol_has_gradient Mol_has_gradient proc~mol_set_gradient_aa->proc~mol_has_gradient Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~mol_set_gradient_aa~~CalledByGraph proc~mol_set_gradient_aa Mol_set_gradient_aa proc~mol_interpolate Mol_interpolate proc~mol_interpolate->proc~mol_set_gradient_aa proc~embedding_energy Embedding_energy proc~embedding_energy->proc~mol_interpolate proc~embedding_potential Embedding_potential proc~embedding_potential->proc~mol_interpolate Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/mol_set_gradient_aa.html"},{"title":"Mol_set_gradient_ab – PYREMB","text":"public subroutine Mol_set_gradient_ab(this, gradient) Set the aa density gradient of a molecule. Initialize gradient if none exists. Arguments Type Intent Optional Attributes Name type( molecule_t ), intent(inout) :: this Input: molecule real(kind=DP), intent(in) :: gradient (:) Input: gradient, 1D array of length ngpt Calls proc~~mol_set_gradient_ab~~CallsGraph proc~mol_set_gradient_ab Mol_set_gradient_ab proc~mol_has_gradient Mol_has_gradient proc~mol_set_gradient_ab->proc~mol_has_gradient Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~mol_set_gradient_ab~~CalledByGraph proc~mol_set_gradient_ab Mol_set_gradient_ab proc~mol_interpolate Mol_interpolate proc~mol_interpolate->proc~mol_set_gradient_ab proc~embedding_energy Embedding_energy proc~embedding_energy->proc~mol_interpolate proc~embedding_potential Embedding_potential proc~embedding_potential->proc~mol_interpolate Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/mol_set_gradient_ab.html"},{"title":"Mol_set_gradient_bb – PYREMB","text":"public subroutine Mol_set_gradient_bb(this, gradient) Set the aa density gradient of a molecule. Initialize gradient if none exists. Arguments Type Intent Optional Attributes Name type( molecule_t ), intent(inout) :: this Input: molecule real(kind=DP), intent(in) :: gradient (:) Input: gradient, 1D array of length ngpt Calls proc~~mol_set_gradient_bb~~CallsGraph proc~mol_set_gradient_bb Mol_set_gradient_bb proc~mol_has_gradient Mol_has_gradient proc~mol_set_gradient_bb->proc~mol_has_gradient Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~mol_set_gradient_bb~~CalledByGraph proc~mol_set_gradient_bb Mol_set_gradient_bb proc~mol_interpolate Mol_interpolate proc~mol_interpolate->proc~mol_set_gradient_bb proc~embedding_energy Embedding_energy proc~embedding_energy->proc~mol_interpolate proc~embedding_potential Embedding_potential proc~embedding_potential->proc~mol_interpolate Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/mol_set_gradient_bb.html"},{"title":"Mol_init_grid – PYREMB","text":"public subroutine Mol_init_grid(this, weights, cell, positions) Initialize the grid of a molecule. This requires nothing, but accepts weights, cell information and grid positions. Arguments Type Intent Optional Attributes Name type( molecule_t ), intent(inout) :: this Input: molecule real(kind=DP), intent(in), optional :: weights (:) Input: grid weights, size ngpt real(kind=DP), intent(in), optional :: cell (:,:) Input: unit cell, size (3, 3) real(kind=DP), intent(in), optional :: positions (:,:) Input: grid weights, size (3, ngpt); first index is x, y, z Calls proc~~mol_init_grid~~CallsGraph proc~mol_init_grid Mol_init_grid proc~grid_set_weights Grid_set_weights proc~mol_init_grid->proc~grid_set_weights proc~grid_set_cell Grid_set_cell proc~mol_init_grid->proc~grid_set_cell proc~mol_has_grid Mol_has_grid proc~mol_init_grid->proc~mol_has_grid proc~grid_set_positions Grid_set_positions proc~mol_init_grid->proc~grid_set_positions proc~grid_has_weights Grid_has_weights proc~grid_set_weights->proc~grid_has_weights proc~error Error proc~grid_set_cell->proc~error proc~grid_has_cell Grid_has_cell proc~grid_set_cell->proc~grid_has_cell proc~grid_set_points_xyz Grid_set_points_xyz proc~grid_set_cell->proc~grid_set_points_xyz proc~grid_has_positions Grid_has_positions proc~grid_set_positions->proc~grid_has_positions Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~mol_init_grid~~CalledByGraph proc~mol_init_grid Mol_init_grid program~test Test program~test->proc~mol_init_grid Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/mol_init_grid.html"},{"title":"Mol_init_ions – PYREMB","text":"public subroutine Mol_init_ions(this, nions, charges, positions) Initialize the ions of a molecule. This requires #ions, their charges and xyz positions. Arguments Type Intent Optional Attributes Name type( molecule_t ), intent(inout) :: this Input: molecule integer, intent(in) :: nions Input: number of ions real(kind=DP), intent(in) :: charges (:) Input: nuclear (effective) charges, size nions real(kind=DP), intent(in) :: positions (:,:) Input: nuclear positions, size (3, nions); first index is x, y, z Calls proc~~mol_init_ions~~CallsGraph proc~mol_init_ions Mol_init_ions proc~ions_set_charges Ions_set_charges proc~mol_init_ions->proc~ions_set_charges proc~mol_has_ions Mol_has_ions proc~mol_init_ions->proc~mol_has_ions proc~ions_set_positions Ions_set_positions proc~mol_init_ions->proc~ions_set_positions proc~ions_has_charges Ions_has_charges proc~ions_set_charges->proc~ions_has_charges proc~ions_has_positions Ions_has_positions proc~ions_set_positions->proc~ions_has_positions Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~mol_init_ions~~CalledByGraph proc~mol_init_ions Mol_init_ions program~test Test program~test->proc~mol_init_ions Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/mol_init_ions.html"},{"title":"Grid_set_weights – PYREMB","text":"public subroutine Grid_set_weights(this, weights) Set the weights of a grid. Initialize weights if none exist. Arguments Type Intent Optional Attributes Name type( grid_t ), intent(inout) :: this Input: grid real(kind=DP), intent(in) :: weights (:) Input: weights, 1D array of size ngpt Calls proc~~grid_set_weights~~CallsGraph proc~grid_set_weights Grid_set_weights proc~grid_has_weights Grid_has_weights proc~grid_set_weights->proc~grid_has_weights Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~grid_set_weights~~CalledByGraph proc~grid_set_weights Grid_set_weights proc~mol_init_grid Mol_init_grid proc~mol_init_grid->proc~grid_set_weights program~test Test program~test->proc~mol_init_grid Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/grid_set_weights.html"},{"title":"Grid_set_points_xyz – PYREMB","text":"public subroutine Grid_set_points_xyz(this, ngptx, ngpty, ngptz) Set the x y and z points of a grid. Arguments Type Intent Optional Attributes Name type( grid_t ), intent(inout) :: this Input: grid integer, intent(in) :: ngptx Input: grid points in each direction integer, intent(in) :: ngpty Input: grid points in each direction integer, intent(in) :: ngptz Input: grid points in each direction Called by proc~~grid_set_points_xyz~~CalledByGraph proc~grid_set_points_xyz Grid_set_points_xyz proc~grid_set_cell Grid_set_cell proc~grid_set_cell->proc~grid_set_points_xyz proc~mol_init_grid Mol_init_grid proc~mol_init_grid->proc~grid_set_cell program~test Test program~test->proc~mol_init_grid Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/grid_set_points_xyz.html"},{"title":"Grid_set_cell – PYREMB","text":"public subroutine Grid_set_cell(this, cell, ngptx, ngpty, ngptz) Set the cell of a grid. Initialize cell if none exists. Arguments Type Intent Optional Attributes Name type( grid_t ), intent(inout) :: this Input: grid real(kind=DP), intent(in) :: cell (:,:) Input: cell, 2D array of size (3, 3), contains cell vectors integer, intent(in), optional :: ngptx Input, optional: grid points in each direction integer, intent(in), optional :: ngpty Input, optional: grid points in each direction integer, intent(in), optional :: ngptz Input, optional: grid points in each direction Calls proc~~grid_set_cell~~CallsGraph proc~grid_set_cell Grid_set_cell proc~error Error proc~grid_set_cell->proc~error proc~grid_has_cell Grid_has_cell proc~grid_set_cell->proc~grid_has_cell proc~grid_set_points_xyz Grid_set_points_xyz proc~grid_set_cell->proc~grid_set_points_xyz Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~grid_set_cell~~CalledByGraph proc~grid_set_cell Grid_set_cell proc~mol_init_grid Mol_init_grid proc~mol_init_grid->proc~grid_set_cell program~test Test program~test->proc~mol_init_grid Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/grid_set_cell.html"},{"title":"Grid_set_positions – PYREMB","text":"public subroutine Grid_set_positions(this, positions) Set the positions of a grid. Initialize positions if none exist. Arguments Type Intent Optional Attributes Name type( grid_t ), intent(inout) :: this Input: grid real(kind=DP), intent(in) :: positions (:,:) Input: cell, 2D array of size (3, ngpt), first index is x, y, z Calls proc~~grid_set_positions~~CallsGraph proc~grid_set_positions Grid_set_positions proc~grid_has_positions Grid_has_positions proc~grid_set_positions->proc~grid_has_positions Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~grid_set_positions~~CalledByGraph proc~grid_set_positions Grid_set_positions proc~mol_init_grid Mol_init_grid proc~mol_init_grid->proc~grid_set_positions proc~grid_pos_from_cell Grid_pos_from_cell proc~grid_pos_from_cell->proc~grid_set_positions proc~mol_interpolate Mol_interpolate proc~mol_interpolate->proc~grid_pos_from_cell program~test Test program~test->proc~mol_init_grid proc~embedding_energy Embedding_energy proc~embedding_energy->proc~mol_interpolate proc~embedding_potential Embedding_potential proc~embedding_potential->proc~mol_interpolate Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/grid_set_positions.html"},{"title":"Ions_set_charges – PYREMB","text":"public subroutine Ions_set_charges(this, charges) Set the charges of ions. Initialize charges if none exist. Arguments Type Intent Optional Attributes Name type( ions_t ), intent(inout) :: this Input: ions real(kind=DP), intent(in) :: charges (:) Input: charges, 1D array of size nions Calls proc~~ions_set_charges~~CallsGraph proc~ions_set_charges Ions_set_charges proc~ions_has_charges Ions_has_charges proc~ions_set_charges->proc~ions_has_charges Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~ions_set_charges~~CalledByGraph proc~ions_set_charges Ions_set_charges proc~mol_init_ions Mol_init_ions proc~mol_init_ions->proc~ions_set_charges program~test Test program~test->proc~mol_init_ions Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/ions_set_charges.html"},{"title":"Ions_set_positions – PYREMB","text":"public subroutine Ions_set_positions(this, positions) Set the positions of ions. Initialize positions if none exist. Arguments Type Intent Optional Attributes Name type( ions_t ), intent(inout) :: this Input: ions real(kind=DP), intent(in) :: positions (:,:) Input: charges, 2D array of size (3, nions) Calls proc~~ions_set_positions~~CallsGraph proc~ions_set_positions Ions_set_positions proc~ions_has_positions Ions_has_positions proc~ions_set_positions->proc~ions_has_positions Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~ions_set_positions~~CalledByGraph proc~ions_set_positions Ions_set_positions proc~mol_init_ions Mol_init_ions proc~mol_init_ions->proc~ions_set_positions program~test Test program~test->proc~mol_init_ions Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/ions_set_positions.html"},{"title":"Integrate – PYREMB","text":"public function Integrate(array, grid) result(integral) Integration of arbitrary functions a_i on arbitrary grids. This is simply a sum, i. e. \\sum_{i=1}&#94;{N_{gpt}} w_i \\cdot a_i when weights w_i are given and \\sum_{i=1}&#94;{N_{gpt}} a_i else. Here array is a_i , grid%weights is w_i , ngpot is N_{gpt} . Todo Specific method for cells Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: array (:) Input: any array type( grid_t ), intent(in), optional :: grid Input: grid, has to have the same number of points as the array Return Value real(kind=DP) Output: the calculated integral Calls proc~~integrate~~CallsGraph proc~integrate Integrate proc~grid_volume Grid_volume proc~integrate->proc~grid_volume proc~grid_has_cell Grid_has_cell proc~integrate->proc~grid_has_cell proc~grid_has_weights Grid_has_weights proc~integrate->proc~grid_has_weights proc~grid_volume->proc~grid_has_cell proc~cross Cross proc~grid_volume->proc~cross Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~integrate~~CalledByGraph proc~integrate Integrate proc~embedding_energy Embedding_energy proc~embedding_energy->proc~integrate proc~xc_energy Xc_energy proc~xc_energy->proc~integrate program~test Test program~test->proc~integrate program~test->proc~xc_energy Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/integrate.html"},{"title":"Grid_volume – PYREMB","text":"public function Grid_volume(grid) result(volume) Calculation of the volume of the cell associated with a given grid. Arguments Type Intent Optional Attributes Name type( grid_t ), intent(in) :: grid Input: grid, has to have a cell Return Value real(kind=DP) Output: the calculated volume Calls proc~~grid_volume~~CallsGraph proc~grid_volume Grid_volume proc~cross Cross proc~grid_volume->proc~cross proc~grid_has_cell Grid_has_cell proc~grid_volume->proc~grid_has_cell Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~grid_volume~~CalledByGraph proc~grid_volume Grid_volume proc~integrate Integrate proc~integrate->proc~grid_volume proc~embedding_energy Embedding_energy proc~embedding_energy->proc~integrate proc~xc_energy Xc_energy proc~xc_energy->proc~integrate program~test Test program~test->proc~integrate program~test->proc~xc_energy Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/grid_volume.html"},{"title":"Cross – PYREMB","text":"public pure function Cross(a, b) result(c) Calculation of the cross product of two vectors Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: a (1:3) Input: two 3D vectors real(kind=DP), intent(in) :: b (1:3) Input: two 3D vectors Return Value real(kind=DP)\n  (1:3) Output: one 3D vector Called by proc~~cross~~CalledByGraph proc~cross Cross proc~grid_volume Grid_volume proc~grid_volume->proc~cross proc~integrate Integrate proc~integrate->proc~grid_volume proc~embedding_energy Embedding_energy proc~embedding_energy->proc~integrate proc~xc_energy Xc_energy proc~xc_energy->proc~integrate program~test Test program~test->proc~integrate program~test->proc~xc_energy Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/cross.html"},{"title":"Grid_pos_from_cell – PYREMB","text":"public subroutine Grid_pos_from_cell(grid) Calculation of grid positions from cell vectors and grid points. Note here, x is the fastest dimension,\n this is different for cube files, where z is fastest,\n thus, reading cubes and converting into our format will be slow Arguments Type Intent Optional Attributes Name type( grid_t ), intent(inout) :: grid Input: grid, has to have a cell Calls proc~~grid_pos_from_cell~~CallsGraph proc~grid_pos_from_cell Grid_pos_from_cell proc~grid_has_periodicity Grid_has_periodicity proc~grid_pos_from_cell->proc~grid_has_periodicity proc~grid_set_positions Grid_set_positions proc~grid_pos_from_cell->proc~grid_set_positions proc~grid_has_points_xyz Grid_has_points_xyz proc~grid_has_periodicity->proc~grid_has_points_xyz proc~grid_has_cell Grid_has_cell proc~grid_has_periodicity->proc~grid_has_cell proc~grid_has_positions Grid_has_positions proc~grid_set_positions->proc~grid_has_positions Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~grid_pos_from_cell~~CalledByGraph proc~grid_pos_from_cell Grid_pos_from_cell proc~mol_interpolate Mol_interpolate proc~mol_interpolate->proc~grid_pos_from_cell proc~embedding_energy Embedding_energy proc~embedding_energy->proc~mol_interpolate proc~embedding_potential Embedding_potential proc~embedding_potential->proc~mol_interpolate Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/grid_pos_from_cell.html"},{"title":"Mol_interpolate – PYREMB","text":"public subroutine Mol_interpolate(molecule, ingrid) Interpolation of all functions in a molecule onto some grid. This subroutine interpolates density, gradient and nuclear potential\n of a molecule onto a given grid.\n An implementation of Shepards method is used. Arguments Type Intent Optional Attributes Name type( molecule_t ), intent(inout) :: molecule Input: molecule, will be modified type( grid_t ), intent(in) :: ingrid Input: grid Calls proc~~mol_interpolate~~CallsGraph proc~mol_interpolate Mol_interpolate proc~grid_has_periodicity Grid_has_periodicity proc~mol_interpolate->proc~grid_has_periodicity proc~mol_set_density Mol_set_density proc~mol_interpolate->proc~mol_set_density proc~mol_set_gradient_aa Mol_set_gradient_aa proc~mol_interpolate->proc~mol_set_gradient_aa proc~error Error proc~mol_interpolate->proc~error proc~grid_has_positions Grid_has_positions proc~mol_interpolate->proc~grid_has_positions proc~shepard_interpolate Shepard_interpolate proc~mol_interpolate->proc~shepard_interpolate proc~mol_has_density Mol_has_density proc~mol_interpolate->proc~mol_has_density proc~mol_set_gradient_ab Mol_set_gradient_ab proc~mol_interpolate->proc~mol_set_gradient_ab proc~mol_set_density_a Mol_set_density_a proc~mol_interpolate->proc~mol_set_density_a proc~mol_set_gradient_bb Mol_set_gradient_bb proc~mol_interpolate->proc~mol_set_gradient_bb proc~mol_has_gradient Mol_has_gradient proc~mol_interpolate->proc~mol_has_gradient proc~mol_set_density_b Mol_set_density_b proc~mol_interpolate->proc~mol_set_density_b proc~mol_set_vnuc Mol_set_vnuc proc~mol_interpolate->proc~mol_set_vnuc proc~mol_set_gradient Mol_set_gradient proc~mol_interpolate->proc~mol_set_gradient proc~mol_set_grid Mol_set_grid proc~mol_interpolate->proc~mol_set_grid proc~grid_pos_from_cell Grid_pos_from_cell proc~mol_interpolate->proc~grid_pos_from_cell proc~mol_has_grid Mol_has_grid proc~mol_interpolate->proc~mol_has_grid proc~mol_has_vnuc Mol_has_vnuc proc~mol_interpolate->proc~mol_has_vnuc proc~grid_has_points_xyz Grid_has_points_xyz proc~grid_has_periodicity->proc~grid_has_points_xyz proc~grid_has_cell Grid_has_cell proc~grid_has_periodicity->proc~grid_has_cell proc~mol_set_density->proc~mol_has_density proc~mol_set_gradient_aa->proc~mol_has_gradient proc~mol_set_gradient_ab->proc~mol_has_gradient proc~mol_set_density_a->proc~mol_has_density proc~mol_set_gradient_bb->proc~mol_has_gradient proc~mol_set_density_b->proc~mol_has_density proc~mol_set_vnuc->proc~mol_has_vnuc proc~mol_set_gradient->proc~mol_has_gradient proc~mol_set_grid->proc~mol_has_grid proc~grid_pos_from_cell->proc~grid_has_periodicity proc~grid_set_positions Grid_set_positions proc~grid_pos_from_cell->proc~grid_set_positions proc~grid_set_positions->proc~grid_has_positions Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~mol_interpolate~~CalledByGraph proc~mol_interpolate Mol_interpolate proc~embedding_energy Embedding_energy proc~embedding_energy->proc~mol_interpolate proc~embedding_potential Embedding_potential proc~embedding_potential->proc~mol_interpolate Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/mol_interpolate.html"},{"title":"Shepard_interpolate – PYREMB","text":"public subroutine Shepard_interpolate(ref_pos, ref_func, pos, func) Shepard interpolation of a 3D function f_j given on positions \\pmb{r}_{ref,j} onto a grid defined by positions \\pmb{r}_i . This is the basic, global Shepard method: Q_i = \\frac{ \\sum_{j=1}&#94;{M} w_i(\\pmb{r}_{ref,j})\\cdot f_j }{ \\sum_{j=1}&#94;{M} w_i(\\pmb{r}_{ref,j}) } with w_i(\\pmb{r}_j) = \\frac{1}{d_{i,j}&#94;2} and d_{i,j}&#94;2 = |\\pmb{r}_i - \\pmb{r}_{ref,j}|&#94;2 . ref_pos is \\pmb{r}_{ref,j} , ref_func is f_j , pos is \\pmb{r}_i and func is Q_i . Ref.: Shepard D (1968) A two-dimensional interpolation function for irregularly spaced data \n       Proc. 23rd Nat. Conf. ACM 517-523 Brandon/Systems Press Inc., Princeton \n DOI: https://dx.doi.org/10.1145/800186.810616 Note Might need to rescale everything if the integral has to be the same! Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: ref_pos (:,:) Input: reference position and target position real(kind=DP), intent(in) :: ref_func (:) Input: reference function real(kind=DP), intent(in) :: pos (:,:) Input: reference position and target position real(kind=DP), intent(out) :: func (:) Output: interpolated function Called by proc~~shepard_interpolate~~CalledByGraph proc~shepard_interpolate Shepard_interpolate proc~mol_interpolate Mol_interpolate proc~mol_interpolate->proc~shepard_interpolate program~test Test program~test->proc~shepard_interpolate proc~embedding_energy Embedding_energy proc~embedding_energy->proc~mol_interpolate proc~embedding_potential Embedding_potential proc~embedding_potential->proc~mol_interpolate Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/shepard_interpolate.html"},{"title":"Gradient – PYREMB","text":"public subroutine Gradient(molecule) In future, this will calculate gradients of some function on arbitrary grids Arguments Type Intent Optional Attributes Name type( molecule_t ) :: molecule Contents None","tags":"","loc":"proc/gradient.html"},{"title":"Xc_energy – PYREMB","text":"public subroutine Xc_energy(molecule, functional, energy) Arguments Type Intent Optional Attributes Name type( molecule_t ), intent(in) :: molecule character(len=*), intent(in) :: functional real(kind=DP), intent(out) :: energy Calls proc~~xc_energy~~CallsGraph proc~xc_energy Xc_energy proc~error Error proc~xc_energy->proc~error xc_ener xc_ener proc~xc_energy->xc_ener proc~mol_has_gradient Mol_has_gradient proc~xc_energy->proc~mol_has_gradient xc_parse xc_parse proc~xc_energy->xc_parse proc~integrate Integrate proc~xc_energy->proc~integrate proc~grid_volume Grid_volume proc~integrate->proc~grid_volume proc~grid_has_cell Grid_has_cell proc~integrate->proc~grid_has_cell proc~grid_has_weights Grid_has_weights proc~integrate->proc~grid_has_weights proc~grid_volume->proc~grid_has_cell proc~cross Cross proc~grid_volume->proc~cross Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~xc_energy~~CalledByGraph proc~xc_energy Xc_energy program~test Test program~test->proc~xc_energy Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/xc_energy.html"},{"title":"Xc_potential – PYREMB","text":"public subroutine Xc_potential(molecule, functional, potential) Arguments Type Intent Optional Attributes Name type( molecule_t ), intent(in) :: molecule character(len=*), intent(in) :: functional real(kind=DP), intent(out) :: potential (:) Calls proc~~xc_potential~~CallsGraph proc~xc_potential Xc_potential proc~mol_has_gradient Mol_has_gradient proc~xc_potential->proc~mol_has_gradient xc_parse xc_parse proc~xc_potential->xc_parse xc_pot xc_pot proc~xc_potential->xc_pot proc~error Error proc~xc_potential->proc~error Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called by proc~~xc_potential~~CalledByGraph proc~xc_potential Xc_potential program~test Test program~test->proc~xc_potential Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/xc_potential.html"},{"title":"Xc_ener – PYREMB","text":"public subroutine Xc_ener(functional, ngpt, spinpol, enerdens, density, gradient) Arguments Type Intent Optional Attributes Name integer, intent(in) :: functional integer, intent(in) :: ngpt logical, intent(in) :: spinpol real(kind=DP), intent(out) :: enerdens (:) real(kind=DP), intent(in) :: density (:) real(kind=DP), intent(in), optional :: gradient (:) Calls proc~~xc_ener~~CallsGraph proc~xc_ener Xc_ener xc_f90_info_family xc_f90_info_family proc~xc_ener->xc_f90_info_family xc_f90_func_init xc_f90_func_init proc~xc_ener->xc_f90_func_init proc~error Error proc~xc_ener->proc~error xc_f90_func_end xc_f90_func_end proc~xc_ener->xc_f90_func_end Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/xc_ener.html"},{"title":"Xc_pot – PYREMB","text":"public subroutine Xc_pot(functional, ngpt, spinpol, potential, density, gradient) Arguments Type Intent Optional Attributes Name integer, intent(in) :: functional integer, intent(in) :: ngpt logical, intent(in) :: spinpol real(kind=DP), intent(out) :: potential (:) real(kind=DP), intent(in) :: density (:) real(kind=DP), intent(in), optional :: gradient (:) Calls proc~~xc_pot~~CallsGraph proc~xc_pot Xc_pot xc_f90_info_family xc_f90_info_family proc~xc_pot->xc_f90_info_family xc_f90_func_init xc_f90_func_init proc~xc_pot->xc_f90_func_init proc~error Error proc~xc_pot->proc~error xc_f90_func_end xc_f90_func_end proc~xc_pot->xc_f90_func_end Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/xc_pot.html"},{"title":"Xc_parse – PYREMB","text":"public subroutine Xc_parse(funcstring, funcid, functype) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: funcstring integer, intent(out) :: funcid character(len=:), intent(out), allocatable :: functype Calls proc~~xc_parse~~CallsGraph proc~xc_parse Xc_parse xc_f90_functional_get_number xc_f90_functional_get_number proc~xc_parse->xc_f90_functional_get_number xc_f90_family_from_id xc_f90_family_from_id proc~xc_parse->xc_f90_family_from_id Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents None","tags":"","loc":"proc/xc_parse.html"},{"title":"Output_mod – PYREMB","text":"Definition of Error and Warning functions used throughout all of PEREMB Uses Precision_mod module~~output_mod~~UsesGraph module~output_mod Output_mod module~precision_mod Precision_mod module~output_mod->module~precision_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~output_mod~~UsedByGraph module~output_mod Output_mod module~system_mod System_mod module~system_mod->module~output_mod module~types_mod Types_mod module~system_mod->module~types_mod module~peremb_mod Peremb_mod module~peremb_mod->module~output_mod module~peremb_mod->module~system_mod module~utils_mod Utils_mod module~peremb_mod->module~utils_mod module~types_mod->module~output_mod module~xcpot_mod Xcpot_mod module~xcpot_mod->module~output_mod module~xcpot_mod->module~types_mod module~xcpot_mod->module~utils_mod module~utils_mod->module~output_mod module~utils_mod->module~types_mod module~xcpot_libxc_mod Xcpot_libxc_mod module~xcpot_libxc_mod->module~output_mod program~test Test program~test->module~system_mod program~test->module~types_mod program~test->module~xcpot_mod program~test->module~utils_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Subroutines Error Warning Subroutines public subroutine Error (string, int1, int2, real1, real2) Throw an Error determined by a string, print some numbers and \n exit with non-zero status Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string Input: string describing the error integer, intent(in), optional :: int1 Input: integers to print out, optional integer, intent(in), optional :: int2 Input: integers to print out, optional real(kind=DP), intent(in), optional :: real1 Input: floats to print out, optional real(kind=DP), intent(in), optional :: real2 Input: floats to print out, optional public subroutine Warning (string, int1, int2, real1, real2) Throw a Warnig determined by a string, print some numbers, but\n do not exit Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: string Input: string describing the error integer, intent(in), optional :: int1 Input: integers to print out, optional integer, intent(in), optional :: int2 Input: integers to print out, optional real(kind=DP), intent(in), optional :: real1 Input: floats to print out, optional real(kind=DP), intent(in), optional :: real2 Input: floats to print out, optional","tags":"","loc":"module/output_mod.html"},{"title":"Peremb_mod – PYREMB","text":"Main subroutines for periodic subystem DFT calculations Uses Precision_mod Output_mod Utils_mod System_mod module~~peremb_mod~~UsesGraph module~peremb_mod Peremb_mod module~utils_mod Utils_mod module~peremb_mod->module~utils_mod module~system_mod System_mod module~peremb_mod->module~system_mod module~output_mod Output_mod module~peremb_mod->module~output_mod module~precision_mod Precision_mod module~peremb_mod->module~precision_mod module~utils_mod->module~output_mod module~utils_mod->module~precision_mod module~types_mod Types_mod module~utils_mod->module~types_mod module~system_mod->module~output_mod module~system_mod->module~types_mod module~output_mod->module~precision_mod module~types_mod->module~output_mod module~types_mod->module~precision_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Subroutines Embedding_potential Embedding_energy Subroutines public subroutine Embedding_potential (x_func, c_func, k_func, potential) Calculation of embedding potential for the global system. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: x_func Input: exchange functional character(len=*), intent(in) :: c_func Input: correlation functional character(len=*), intent(in) :: k_func Input: kinetic functional real(kind=DP), intent(out) :: potential (:) Output: embedding potential public subroutine Embedding_energy (x_func, c_func, k_func, energy) Calculation of embedding energy for the global system. Read more… Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: x_func Input: exchange functional character(len=*), intent(in) :: c_func Input: correlation functional character(len=*), intent(in) :: k_func Input: kinetic functional real(kind=DP), intent(out) :: energy Output: embedding potential","tags":"","loc":"module/peremb_mod.html"},{"title":"Precision_mod – PYREMB","text":"Consistent definition of precisions, should be IEE-754 standard Used by module~~precision_mod~~UsedByGraph module~precision_mod Precision_mod module~output_mod Output_mod module~output_mod->module~precision_mod module~peremb_mod Peremb_mod module~peremb_mod->module~precision_mod module~peremb_mod->module~output_mod module~utils_mod Utils_mod module~peremb_mod->module~utils_mod module~system_mod System_mod module~peremb_mod->module~system_mod module~types_mod Types_mod module~types_mod->module~precision_mod module~types_mod->module~output_mod module~xcpot_mod Xcpot_mod module~xcpot_mod->module~precision_mod module~xcpot_mod->module~output_mod module~xcpot_mod->module~types_mod module~xcpot_mod->module~utils_mod program~test Test program~test->module~precision_mod program~test->module~types_mod program~test->module~xcpot_mod program~test->module~utils_mod program~test->module~system_mod module~utils_mod->module~precision_mod module~utils_mod->module~output_mod module~utils_mod->module~types_mod module~xcpot_libxc_mod Xcpot_libxc_mod module~xcpot_libxc_mod->module~precision_mod module~xcpot_libxc_mod->module~output_mod module~system_mod->module~output_mod module~system_mod->module~types_mod var panmoduleprecision_modUsedByGraph = svgPanZoom('#moduleprecision_modUsedByGraph', {zoomEnabled: true,controlIconsEnabled: true, fit: true, center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables SP DP QP Variables Type Visibility Attributes Name Initial integer, public, parameter :: SP = Selected_real_kind(p=6, r=37) Single precision integer, public, parameter :: DP = Selected_real_kind(p=15, r=307) Double precision integer, public, parameter :: QP = Selected_real_kind(p=33, r=4931) Quadruple precision","tags":"","loc":"module/precision_mod.html"},{"title":"System_mod – PYREMB","text":"Definition of the GLOBAL total system, which can contain any number of molecules. Uses Output_mod Types_mod module~~system_mod~~UsesGraph module~system_mod System_mod module~types_mod Types_mod module~system_mod->module~types_mod module~output_mod Output_mod module~system_mod->module~output_mod module~types_mod->module~output_mod module~precision_mod Precision_mod module~types_mod->module~precision_mod module~output_mod->module~precision_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~system_mod~~UsedByGraph module~system_mod System_mod module~peremb_mod Peremb_mod module~peremb_mod->module~system_mod program~test Test program~test->module~system_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Variables nsys system Subroutines Init Sys_init Variables Type Visibility Attributes Name Initial integer, public :: nsys Number of subsystems, the only thing you have to know beforehand type( molecule_t ), public, allocatable :: system (:) THE system, just an array of molecules, but GLOBAL! Subroutines public subroutine Init (numsys) Basic initialization of the system, not specifying any molecules Arguments Type Intent Optional Attributes Name integer, intent(in) :: numsys Input: number of subsystems public subroutine Sys_init (subsystem, density, vnuc, gridweights, gridpositions, active, spin) Initialize a subsystem, optionally with all important parameters. Arguments Type Intent Optional Attributes Name integer, intent(in) :: subsystem Input: index of the subsystem real(kind=DP), intent(in) :: density (:) Input: density, 1D array of length ngpt (or 2*ngpt if spin polarized; order is a, b) real(kind=DP), intent(in), optional :: vnuc (:) Input: nuclear potential, of length ngpt real(kind=DP), intent(in), optional :: gridweights (:) Input: grid weights, length ngpt real(kind=DP), intent(in), optional :: gridpositions (:,:) Input: grid positions, length (3,ngpt) logical, intent(in), optional :: active Input: whether the system is active logical, intent(in), optional :: spin Input: whether the system is spin polarized","tags":"","loc":"module/system_mod.html"},{"title":"Types_mod – PYREMB","text":"Definition of all Data Types and their functions Molecule functions Grid functions Ions functions Uses Precision_mod Output_mod module~~types_mod~~UsesGraph module~types_mod Types_mod module~output_mod Output_mod module~types_mod->module~output_mod module~precision_mod Precision_mod module~types_mod->module~precision_mod module~output_mod->module~precision_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~types_mod~~UsedByGraph module~types_mod Types_mod module~utils_mod Utils_mod module~utils_mod->module~types_mod module~system_mod System_mod module~system_mod->module~types_mod module~xcpot_mod Xcpot_mod module~xcpot_mod->module~types_mod module~xcpot_mod->module~utils_mod program~test Test program~test->module~types_mod program~test->module~utils_mod program~test->module~system_mod program~test->module~xcpot_mod module~peremb_mod Peremb_mod module~peremb_mod->module~utils_mod module~peremb_mod->module~system_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Derived Types grid_t ions_t molecule_t Functions Mol_has_grid Mol_has_vnuc Mol_has_ions Mol_has_density Mol_has_gradient Grid_has_weights Grid_has_cell Grid_has_positions Grid_has_points_xyz Grid_has_periodicity Ions_has_charges Ions_has_positions Subroutines Mol_set_grid Mol_set_vnuc Mol_set_ions Mol_set_spin Mol_set_density Mol_set_density_a Mol_set_density_b Mol_set_gradient Mol_set_gradient_aa Mol_set_gradient_ab Mol_set_gradient_bb Mol_init_grid Mol_init_ions Grid_set_weights Grid_set_points_xyz Grid_set_cell Grid_set_positions Ions_set_charges Ions_set_positions Derived Types type, public :: grid_t Grid type, contains points, weights, cell and positions Read more… Components Type Visibility Attributes Name Initial integer, public :: ngpt Number of grid points integer, public :: ngptx = -1.0_DP Number of grid points in each direction, for periodic cells integer, public :: ngpty = -1.0_DP Number of grid points in each direction, for periodic cells integer, public :: ngptz = -1.0_DP Number of grid points in each direction, for periodic cells real(kind=DP), public, allocatable :: weights (:) Weights; size = ngpt, optional real(kind=DP), public, allocatable :: cell (:,:) Cell vectors; size = (3, 3), optional real(kind=DP), public, allocatable :: positions (:,:) Positions; size = (3, ngpt), first index is x,y,z, optional type, public :: ions_t Ions type, contains number, charges and positions Read more… Components Type Visibility Attributes Name Initial integer, public :: nions Number of ions real(kind=DP), public, allocatable :: charges (:) Charges; size = nions real(kind=DP), public, allocatable :: positions (:,:) Positions; size = (3, nions), first index is x,y,z type, public :: molecule_t Molecule type, contains points, grid, density, nuclear potential and ions Read more… Components Type Visibility Attributes Name Initial integer, public :: ngpt Number of grid points type( grid_t ), public, pointer :: grid => null() Grid, may contain weights, cell and positions real(kind=DP), public, allocatable :: density (:) Electron density; size = ngpt for unpolarized or 2 * ngpt for spin polarized, beta is from ngpt + 1:2 * ngpt real(kind=DP), public, allocatable :: gradient (:) Density gradient |\\nabla\\rho|&#94;2 ; size = npgt for unpolarized or 3 * ngpt for spin polarized, order is aa,ab,bb real(kind=DP), public, allocatable :: vnuc (:) Nuclear potential; size = ngpt, alternative to ions type( ions_t ), public, pointer :: ions => null() Ions, contains number of ions, charges and positions logical, public :: spinpol = .false. Spin polarized or not logical, public :: active = .false. Active or not Functions public pure function Mol_has_grid (this) result(hasgrid) Return .true. if the molecule has a grid. Arguments Type Intent Optional Attributes Name type( molecule_t ), intent(in) :: this Input: molecule Return Value logical Output: whether the molecule has a grid public pure function Mol_has_vnuc (this) result(hasvnuc) Return .true. if the molecule has a vnuc (nuclear potential). Arguments Type Intent Optional Attributes Name type( molecule_t ), intent(in) :: this Input: molecule Return Value logical Output: whether the molecule has a vnuc public pure function Mol_has_ions (this) result(hasions) Return .true. if the molecule has ions. Arguments Type Intent Optional Attributes Name type( molecule_t ), intent(in) :: this Input: molecule Return Value logical Output: whether the molecule has ions public pure function Mol_has_density (this) result(hasdensity) Return .true. if the molecule has a density. Arguments Type Intent Optional Attributes Name type( molecule_t ), intent(in) :: this Input: molecule Return Value logical Output: whether the molecule has a density public pure function Mol_has_gradient (this) result(hasgradient) Return .true. if the molecule has a density gradient. Arguments Type Intent Optional Attributes Name type( molecule_t ), intent(in) :: this Input: molecule Return Value logical Output: whether the molecule has a gradient public pure function Grid_has_weights (this) result(hasweights) Return .true. if the grid has weights. Arguments Type Intent Optional Attributes Name type( grid_t ), intent(in) :: this Input: grid Return Value logical Output: whether the grid has weights public pure function Grid_has_cell (this) result(hascell) Return .true. if the grid has a cell. Arguments Type Intent Optional Attributes Name type( grid_t ), intent(in) :: this Input: grid Return Value logical Output: whether the grid has a cell public pure function Grid_has_positions (this) result(haspositions) Return .true. if the grid has positions. Arguments Type Intent Optional Attributes Name type( grid_t ), intent(in) :: this Input: grid Return Value logical Output: whether the grid has a cell public pure function Grid_has_points_xyz (this) result(haspointsxyz) Return .true. if the grid has points for all directions Arguments Type Intent Optional Attributes Name type( grid_t ), intent(in) :: this Input: grid Return Value logical Output: whether the grid has points for all directions public pure function Grid_has_periodicity (this) result(hasperiodicity) Return .true. if the grid has all properties associated with periodicity Arguments Type Intent Optional Attributes Name type( grid_t ), intent(in) :: this Input: grid Return Value logical Output: whether the grid has all properties associated with periodicity public pure function Ions_has_charges (this) result(hascharges) Return .true. if the ions have charges. \n Even though ions should always be initialized with charges, it is not impossible to not have charges. Arguments Type Intent Optional Attributes Name type( ions_t ), intent(in) :: this Input: ions Return Value logical Output: whether the ions have charges public pure function Ions_has_positions (this) result(haspositions) Return .true. if the ions have positions. \n Even though ions should always be initialized with positions, it is not impossible to not have positions. Arguments Type Intent Optional Attributes Name type( ions_t ), intent(in) :: this Input: ions Return Value logical Output: whether the ions have positions Subroutines public subroutine Mol_set_grid (this, grid) Set the grid of a molecule. Initialize a grid if none exists. Arguments Type Intent Optional Attributes Name type( molecule_t ), intent(inout) :: this Input: molecule type( grid_t ), intent(in) :: grid Input: grid, ngpt has to be ngpt of molecule public subroutine Mol_set_vnuc (this, vnuc) Set the nuclear potential of a molecule. Initialize one if none exists. Arguments Type Intent Optional Attributes Name type( molecule_t ), intent(inout) :: this Input: molecule real(kind=DP), intent(in) :: vnuc (:) Input: nuclear potential, 1D array of size ngpt public pure subroutine Mol_set_ions (this, ions) Set the ions of a molecule. Initialize if none exist. Arguments Type Intent Optional Attributes Name type( molecule_t ), intent(inout) :: this Input: molecule type( ions_t ), intent(in) :: ions Input: ions public subroutine Mol_set_spin (this, spinpol) Set the spin of a molecule. If density or gradient exist, they are deallocated! Arguments Type Intent Optional Attributes Name type( molecule_t ), intent(inout) :: this Input: molecule logical, intent(in) :: spinpol Input: spin ( .true. = spin polarized, .false. = unpolarized ) public subroutine Mol_set_density (this, density) Set the density of a molecule. Initialize density if none exists. Arguments Type Intent Optional Attributes Name type( molecule_t ), intent(inout) :: this Input: molecule real(kind=DP), intent(in) :: density (:) Input: density, 1D array of length ngpt (or 2*ngpt if spin polarized; order is a, b) public subroutine Mol_set_density_a (this, density) Set the alpha spin density of a molecule. Initialize density if none exists. Arguments Type Intent Optional Attributes Name type( molecule_t ), intent(inout) :: this Input: molecule real(kind=DP), intent(in) :: density (:) Input: density, 1D array of length ngpt public subroutine Mol_set_density_b (this, density) Set the beta spin density of a molecule. Initialize density if none exists. Arguments Type Intent Optional Attributes Name type( molecule_t ), intent(inout) :: this Input: molecule real(kind=DP), intent(in) :: density (:) Input: density, 1D array of length ngpt public subroutine Mol_set_gradient (this, gradient) Set the density gradient of a molecule. Initialize gradient if none exists. Arguments Type Intent Optional Attributes Name type( molecule_t ), intent(inout) :: this Input: molecule real(kind=DP), intent(in) :: gradient (:) Input: gradient, 1D array of length ngpt (3* ngpt if spin polarized; order is aa, ab, bb) public subroutine Mol_set_gradient_aa (this, gradient) Set the aa density gradient of a molecule. Initialize gradient if none exists. Arguments Type Intent Optional Attributes Name type( molecule_t ), intent(inout) :: this Input: molecule real(kind=DP), intent(in) :: gradient (:) Input: gradient, 1D array of length ngpt public subroutine Mol_set_gradient_ab (this, gradient) Set the aa density gradient of a molecule. Initialize gradient if none exists. Arguments Type Intent Optional Attributes Name type( molecule_t ), intent(inout) :: this Input: molecule real(kind=DP), intent(in) :: gradient (:) Input: gradient, 1D array of length ngpt public subroutine Mol_set_gradient_bb (this, gradient) Set the aa density gradient of a molecule. Initialize gradient if none exists. Arguments Type Intent Optional Attributes Name type( molecule_t ), intent(inout) :: this Input: molecule real(kind=DP), intent(in) :: gradient (:) Input: gradient, 1D array of length ngpt public subroutine Mol_init_grid (this, weights, cell, positions) Initialize the grid of a molecule. This requires nothing, but accepts weights, cell information and grid positions. Arguments Type Intent Optional Attributes Name type( molecule_t ), intent(inout) :: this Input: molecule real(kind=DP), intent(in), optional :: weights (:) Input: grid weights, size ngpt real(kind=DP), intent(in), optional :: cell (:,:) Input: unit cell, size (3, 3) real(kind=DP), intent(in), optional :: positions (:,:) Input: grid weights, size (3, ngpt); first index is x, y, z public subroutine Mol_init_ions (this, nions, charges, positions) Initialize the ions of a molecule. This requires #ions, their charges and xyz positions. Arguments Type Intent Optional Attributes Name type( molecule_t ), intent(inout) :: this Input: molecule integer, intent(in) :: nions Input: number of ions real(kind=DP), intent(in) :: charges (:) Input: nuclear (effective) charges, size nions real(kind=DP), intent(in) :: positions (:,:) Input: nuclear positions, size (3, nions); first index is x, y, z public subroutine Grid_set_weights (this, weights) Set the weights of a grid. Initialize weights if none exist. Arguments Type Intent Optional Attributes Name type( grid_t ), intent(inout) :: this Input: grid real(kind=DP), intent(in) :: weights (:) Input: weights, 1D array of size ngpt public subroutine Grid_set_points_xyz (this, ngptx, ngpty, ngptz) Set the x y and z points of a grid. Arguments Type Intent Optional Attributes Name type( grid_t ), intent(inout) :: this Input: grid integer, intent(in) :: ngptx Input: grid points in each direction integer, intent(in) :: ngpty Input: grid points in each direction integer, intent(in) :: ngptz Input: grid points in each direction public subroutine Grid_set_cell (this, cell, ngptx, ngpty, ngptz) Set the cell of a grid. Initialize cell if none exists. Arguments Type Intent Optional Attributes Name type( grid_t ), intent(inout) :: this Input: grid real(kind=DP), intent(in) :: cell (:,:) Input: cell, 2D array of size (3, 3), contains cell vectors integer, intent(in), optional :: ngptx Input, optional: grid points in each direction integer, intent(in), optional :: ngpty Input, optional: grid points in each direction integer, intent(in), optional :: ngptz Input, optional: grid points in each direction public subroutine Grid_set_positions (this, positions) Set the positions of a grid. Initialize positions if none exist. Arguments Type Intent Optional Attributes Name type( grid_t ), intent(inout) :: this Input: grid real(kind=DP), intent(in) :: positions (:,:) Input: cell, 2D array of size (3, ngpt), first index is x, y, z public subroutine Ions_set_charges (this, charges) Set the charges of ions. Initialize charges if none exist. Arguments Type Intent Optional Attributes Name type( ions_t ), intent(inout) :: this Input: ions real(kind=DP), intent(in) :: charges (:) Input: charges, 1D array of size nions public subroutine Ions_set_positions (this, positions) Set the positions of ions. Initialize positions if none exist. Arguments Type Intent Optional Attributes Name type( ions_t ), intent(inout) :: this Input: ions real(kind=DP), intent(in) :: positions (:,:) Input: charges, 2D array of size (3, nions)","tags":"","loc":"module/types_mod.html"},{"title":"Utils_mod – PYREMB","text":"Utility module, contains generally useful subroutines and functions\n like integration, interpolation and other \"light\" math Uses Precision_mod Types_mod Output_mod module~~utils_mod~~UsesGraph module~utils_mod Utils_mod module~types_mod Types_mod module~utils_mod->module~types_mod module~output_mod Output_mod module~utils_mod->module~output_mod module~precision_mod Precision_mod module~utils_mod->module~precision_mod module~types_mod->module~output_mod module~types_mod->module~precision_mod module~output_mod->module~precision_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~utils_mod~~UsedByGraph module~utils_mod Utils_mod module~xcpot_mod Xcpot_mod module~xcpot_mod->module~utils_mod module~peremb_mod Peremb_mod module~peremb_mod->module~utils_mod program~test Test program~test->module~utils_mod program~test->module~xcpot_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Functions Integrate Grid_volume Cross Subroutines Grid_pos_from_cell Mol_interpolate Shepard_interpolate Gradient Functions public function Integrate (array, grid) result(integral) Integration of arbitrary functions a_i on arbitrary grids. Read more… Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: array (:) Input: any array type( grid_t ), intent(in), optional :: grid Input: grid, has to have the same number of points as the array Return Value real(kind=DP) Output: the calculated integral public function Grid_volume (grid) result(volume) Calculation of the volume of the cell associated with a given grid. Read more… Arguments Type Intent Optional Attributes Name type( grid_t ), intent(in) :: grid Input: grid, has to have a cell Return Value real(kind=DP) Output: the calculated volume public pure function Cross (a, b) result(c) Calculation of the cross product of two vectors Read more… Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: a (1:3) Input: two 3D vectors real(kind=DP), intent(in) :: b (1:3) Input: two 3D vectors Return Value real(kind=DP)\n  (1:3) Output: one 3D vector Subroutines public subroutine Grid_pos_from_cell (grid) Calculation of grid positions from cell vectors and grid points. Read more… Arguments Type Intent Optional Attributes Name type( grid_t ), intent(inout) :: grid Input: grid, has to have a cell public subroutine Mol_interpolate (molecule, ingrid) Interpolation of all functions in a molecule onto some grid. Read more… Arguments Type Intent Optional Attributes Name type( molecule_t ), intent(inout) :: molecule Input: molecule, will be modified type( grid_t ), intent(in) :: ingrid Input: grid public subroutine Shepard_interpolate (ref_pos, ref_func, pos, func) Shepard interpolation of a 3D function f_j given on positions \\pmb{r}_{ref,j} onto a grid defined by positions \\pmb{r}_i . Read more… Arguments Type Intent Optional Attributes Name real(kind=DP), intent(in) :: ref_pos (:,:) Input: reference position and target position real(kind=DP), intent(in) :: ref_func (:) Input: reference function real(kind=DP), intent(in) :: pos (:,:) Input: reference position and target position real(kind=DP), intent(out) :: func (:) Output: interpolated function public subroutine Gradient (molecule) In future, this will calculate gradients of some function on arbitrary grids Read more… Arguments Type Intent Optional Attributes Name type( molecule_t ) :: molecule","tags":"","loc":"module/utils_mod.html"},{"title":"Xcpot_mod – PYREMB","text":"Uses Precision_mod Output_mod Types_mod Utils_mod module~~xcpot_mod~~UsesGraph module~xcpot_mod Xcpot_mod module~utils_mod Utils_mod module~xcpot_mod->module~utils_mod module~types_mod Types_mod module~xcpot_mod->module~types_mod module~output_mod Output_mod module~xcpot_mod->module~output_mod module~precision_mod Precision_mod module~xcpot_mod->module~precision_mod module~utils_mod->module~types_mod module~utils_mod->module~output_mod module~utils_mod->module~precision_mod module~types_mod->module~output_mod module~types_mod->module~precision_mod module~output_mod->module~precision_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Used by module~~xcpot_mod~~UsedByGraph module~xcpot_mod Xcpot_mod program~test Test program~test->module~xcpot_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Subroutines Xc_energy Xc_potential Subroutines public subroutine Xc_energy (molecule, functional, energy) Arguments Type Intent Optional Attributes Name type( molecule_t ), intent(in) :: molecule character(len=*), intent(in) :: functional real(kind=DP), intent(out) :: energy public subroutine Xc_potential (molecule, functional, potential) Arguments Type Intent Optional Attributes Name type( molecule_t ), intent(in) :: molecule character(len=*), intent(in) :: functional real(kind=DP), intent(out) :: potential (:)","tags":"","loc":"module/xcpot_mod.html"},{"title":"Xcpot_libxc_mod – PYREMB","text":"Uses Precision_mod Output_mod Xc_f90_types_m Xc_f90_lib_m module~~xcpot_libxc_mod~~UsesGraph module~xcpot_libxc_mod Xcpot_libxc_mod module~precision_mod Precision_mod module~xcpot_libxc_mod->module~precision_mod Xc_f90_types_m Xc_f90_types_m module~xcpot_libxc_mod->Xc_f90_types_m module~output_mod Output_mod module~xcpot_libxc_mod->module~output_mod Xc_f90_lib_m Xc_f90_lib_m module~xcpot_libxc_mod->Xc_f90_lib_m module~output_mod->module~precision_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Contents Subroutines Xc_ener Xc_pot Xc_parse Subroutines public subroutine Xc_ener (functional, ngpt, spinpol, enerdens, density, gradient) Arguments Type Intent Optional Attributes Name integer, intent(in) :: functional integer, intent(in) :: ngpt logical, intent(in) :: spinpol real(kind=DP), intent(out) :: enerdens (:) real(kind=DP), intent(in) :: density (:) real(kind=DP), intent(in), optional :: gradient (:) public subroutine Xc_pot (functional, ngpt, spinpol, potential, density, gradient) Arguments Type Intent Optional Attributes Name integer, intent(in) :: functional integer, intent(in) :: ngpt logical, intent(in) :: spinpol real(kind=DP), intent(out) :: potential (:) real(kind=DP), intent(in) :: density (:) real(kind=DP), intent(in), optional :: gradient (:) public subroutine Xc_parse (funcstring, funcid, functype) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: funcstring integer, intent(out) :: funcid character(len=:), intent(out), allocatable :: functype","tags":"","loc":"module/xcpot_libxc_mod.html"},{"title":"Do_test – PYREMB","text":"normal do loop\n concurrent do loop\n intrinsic sum\n 1 do loop\n 2 do loops\n 2 do loops\n Other test: array maths and sum\n 1 do loop\n intrinsic\n temp array\n Other test: specifically what i do in shepard interpolation\n temp array\n one loop one loop with exit Contents Variables DP array array2 temp mysum tstart tend mysum2 value i n izero Variables Type Attributes Name Initial integer, parameter :: DP = Selected_real_kind(15, 307) real(kind=DP), allocatable :: array (:) real(kind=DP), allocatable :: array2 (:) real(kind=DP), allocatable :: temp (:) real(kind=DP) :: mysum real(kind=DP) :: tstart real(kind=DP) :: tend real(kind=DP) :: mysum2 real(kind=DP) :: value integer :: i integer :: n integer :: izero","tags":"","loc":"program/do_test.html"},{"title":"Test – PYREMB","text":"Uses Precision_mod Types_mod System_mod Utils_mod Xcpot_mod program~~test~~UsesGraph program~test Test module~system_mod System_mod program~test->module~system_mod module~precision_mod Precision_mod program~test->module~precision_mod module~types_mod Types_mod program~test->module~types_mod module~xcpot_mod Xcpot_mod program~test->module~xcpot_mod module~utils_mod Utils_mod program~test->module~utils_mod module~system_mod->module~types_mod module~output_mod Output_mod module~system_mod->module~output_mod module~types_mod->module~precision_mod module~types_mod->module~output_mod module~xcpot_mod->module~precision_mod module~xcpot_mod->module~types_mod module~xcpot_mod->module~utils_mod module~xcpot_mod->module~output_mod module~utils_mod->module~precision_mod module~utils_mod->module~types_mod module~utils_mod->module~output_mod module~output_mod->module~precision_mod Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\n    descended from. Dashed arrows point from a module or program unit to \n    modules which it uses. Test of most of the functions and subroutines, just to see if they work / are correct Calls program~~test~~CallsGraph program~test Test proc~mol_set_density Mol_set_density program~test->proc~mol_set_density proc~xc_potential Xc_potential program~test->proc~xc_potential proc~mol_init_grid Mol_init_grid program~test->proc~mol_init_grid proc~sys_init Sys_init program~test->proc~sys_init proc~shepard_interpolate Shepard_interpolate program~test->proc~shepard_interpolate proc~mol_has_grid Mol_has_grid program~test->proc~mol_has_grid proc~mol_has_density Mol_has_density program~test->proc~mol_has_density proc~mol_set_ions Mol_set_ions program~test->proc~mol_set_ions proc~mol_set_spin Mol_set_spin program~test->proc~mol_set_spin proc~mol_init_ions Mol_init_ions program~test->proc~mol_init_ions proc~mol_set_vnuc Mol_set_vnuc program~test->proc~mol_set_vnuc proc~mol_has_gradient Mol_has_gradient program~test->proc~mol_has_gradient proc~mol_set_gradient Mol_set_gradient program~test->proc~mol_set_gradient proc~ions_has_charges Ions_has_charges program~test->proc~ions_has_charges proc~mol_set_grid Mol_set_grid program~test->proc~mol_set_grid proc~mol_has_ions Mol_has_ions program~test->proc~mol_has_ions proc~integrate Integrate program~test->proc~integrate proc~xc_energy Xc_energy program~test->proc~xc_energy proc~mol_has_vnuc Mol_has_vnuc program~test->proc~mol_has_vnuc proc~mol_set_density->proc~mol_has_density proc~xc_potential->proc~mol_has_gradient proc~error Error proc~xc_potential->proc~error xc_parse xc_parse proc~xc_potential->xc_parse xc_pot xc_pot proc~xc_potential->xc_pot proc~mol_init_grid->proc~mol_has_grid proc~grid_set_weights Grid_set_weights proc~mol_init_grid->proc~grid_set_weights proc~grid_set_cell Grid_set_cell proc~mol_init_grid->proc~grid_set_cell proc~grid_set_positions Grid_set_positions proc~mol_init_grid->proc~grid_set_positions proc~mol_set_ions->proc~mol_has_ions proc~mol_set_spin->proc~mol_has_density proc~mol_set_spin->proc~mol_has_gradient proc~warning Warning proc~mol_set_spin->proc~warning proc~mol_init_ions->proc~mol_has_ions proc~ions_set_charges Ions_set_charges proc~mol_init_ions->proc~ions_set_charges proc~ions_set_positions Ions_set_positions proc~mol_init_ions->proc~ions_set_positions proc~mol_set_vnuc->proc~mol_has_vnuc proc~mol_set_gradient->proc~mol_has_gradient proc~mol_set_grid->proc~mol_has_grid proc~grid_volume Grid_volume proc~integrate->proc~grid_volume proc~grid_has_cell Grid_has_cell proc~integrate->proc~grid_has_cell proc~grid_has_weights Grid_has_weights proc~integrate->proc~grid_has_weights proc~xc_energy->proc~mol_has_gradient proc~xc_energy->proc~integrate proc~xc_energy->proc~error xc_ener xc_ener proc~xc_energy->xc_ener proc~xc_energy->xc_parse proc~grid_set_weights->proc~grid_has_weights proc~grid_set_cell->proc~error proc~grid_set_cell->proc~grid_has_cell proc~grid_set_points_xyz Grid_set_points_xyz proc~grid_set_cell->proc~grid_set_points_xyz proc~grid_volume->proc~grid_has_cell proc~cross Cross proc~grid_volume->proc~cross proc~grid_has_positions Grid_has_positions proc~grid_set_positions->proc~grid_has_positions proc~ions_set_charges->proc~ions_has_charges proc~ions_has_positions Ions_has_positions proc~ions_set_positions->proc~ions_has_positions Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Contents Variables ngpt natoms i dens vnuc q pos cell dens2 mol1 mol2 mol3 grid1 ener pot positions1 positions2 func res_func Variables Type Attributes Name Initial integer :: ngpt number of grid points, number of atoms, loop index integer :: natoms number of grid points, number of atoms, loop index integer :: i number of grid points, number of atoms, loop index real(kind=DP) :: dens (1:3) density, nuclear potential, ion charges, ion positions, cell, another density real(kind=DP) :: vnuc (1:3) density, nuclear potential, ion charges, ion positions, cell, another density real(kind=DP) :: q (1:4) density, nuclear potential, ion charges, ion positions, cell, another density real(kind=DP) :: pos (1:3,1:4) density, nuclear potential, ion charges, ion positions, cell, another density real(kind=DP) :: cell (1:3,1:3) density, nuclear potential, ion charges, ion positions, cell, another density real(kind=DP) :: dens2 (1:2) density, nuclear potential, ion charges, ion positions, cell, another density type( molecule_t ) :: mol1 three molecules type( molecule_t ) :: mol2 three molecules type( molecule_t ) :: mol3 three molecules type( grid_t ) :: grid1 grid real(kind=DP) :: ener dft energy and effective potential real(kind=DP) :: pot (1:3) dft energy and effective potential real(kind=DP) :: positions1 (1:3,1:4) grid positions for two grids, reference and result function for interpolation test real(kind=DP) :: positions2 (1:3,1:5) grid positions for two grids, reference and result function for interpolation test real(kind=DP) :: func (1:4) grid positions for two grids, reference and result function for interpolation test real(kind=DP) :: res_func (1:5) grid positions for two grids, reference and result function for interpolation test","tags":"","loc":"program/test.html"}]}